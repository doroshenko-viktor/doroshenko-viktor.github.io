<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>SQL Databases Concurrency And Locks</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_buildManifest.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_ssgManifest.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">SQL Databases Concurrency And Locks</h1><article class="NoteFormattedContent_note__8cHeE">
<h2>Some Issues Related To Concurrency</h2>
<p>There are problems that can happen when multiple operations try to read and write data at the same time. Knowing these helps fix and design better systems.</p>
<h3>Non-repeatable reads</h3>
<p>Imagine you read a piece of data, and when you check it again moments later, it's different. That's a non-repeatable read. This can happen when others are allowed to change data while you're still working on it.</p>
<h3>Dirty reads</h3>
<p>This is when you read data that someone else is still changing. They haven't finished (or "committed") their change, but you see their work in progress. It's like reading a note someone's still writing.</p>
<h3>Phantom reads</h3>
<p>Imagine you count something (like customers). You count again a bit later, and the number changes because someone added or removed an item, but without telling the system to "protect" that range of data. This sudden appearance or disappearance is called a "phantom" read.</p>
<h2>Range Locks</h2>
<p>Think of locks as ways to protect data. There are different types of locks:</p>
<p>
  <strong>Serialized Access:</strong> Only one task can use the data at a time. It's safe but slow.
  <strong>Table Lock:</strong> Protects the whole table. Better speed, but can still be slow if many tasks want to write data.
  <strong>Row Lock:</strong> Only locks a specific row of data. Faster, but tasks might wait if they need the same row.
  <strong>Range Locks:</strong> These lock a group or "range" of data. They ensure no one adds or changes data in that range while you're working on it.
</p>
<h2>Isolation Levels</h2>
<p>
  SQL has 4 standard isolation levels to decide how data is accessed and protected during operations.
  It's crucial to set a global standard for these levels to avoid unexpected behaviors.
</p>
<p><strong>REPEATABLE READ:</strong></p>
<p>
  Think of it as taking a snapshot when you first read the data. Until you finish your task, that snapshot remains unchanged, even if others make changes.
  It stops problems like seeing different data on multiple reads (non-repeatable reads) or accessing data that's still being edited by others (dirty reads).
  However, to ensure data is always fresh, it's best to keep tasks brief.
</p>
<p><strong>SERIALIZABLE:</strong></p>
<p>
  It's like waiting in line. Only one task can work at a time, ensuring total consistency.
  There's no chance of reading errors because each task finishes completely before the next one starts. But, tasks can sometimes fail
  when too many try to run at once, so a system to try again (retry mechanism) is helpful.
</p>
<p><strong>READ COMMITTED:</strong></p>
<p>
  Unlike REPEATABLE READ, every time you read data, you get a new, updated view. This means you can sometimes read data that appears or disappears
  suddenly (phantom reads) if you read multiple times in one task.
</p>
<p><strong>READ UNCOMMITTED:</strong></p>
<p>
  This is the wild west of isolation levels! You can access data even if someone else is still working on it. This can lead to reading half-finished
  (dirty) data. Not ideal for systems needing accuracy.
</p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["databases","concurrency-and-locks"],"note":{"title":"SQL Databases Concurrency And Locks","date":"2023-08-12","content":"\n\u003ch2\u003eSome Issues Related To Concurrency\u003c/h2\u003e\n\u003cp\u003eThere are problems that can happen when multiple operations try to read and write data at the same time. Knowing these helps fix and design better systems.\u003c/p\u003e\n\u003ch3\u003eNon-repeatable reads\u003c/h3\u003e\n\u003cp\u003eImagine you read a piece of data, and when you check it again moments later, it's different. That's a non-repeatable read. This can happen when others are allowed to change data while you're still working on it.\u003c/p\u003e\n\u003ch3\u003eDirty reads\u003c/h3\u003e\n\u003cp\u003eThis is when you read data that someone else is still changing. They haven't finished (or \"committed\") their change, but you see their work in progress. It's like reading a note someone's still writing.\u003c/p\u003e\n\u003ch3\u003ePhantom reads\u003c/h3\u003e\n\u003cp\u003eImagine you count something (like customers). You count again a bit later, and the number changes because someone added or removed an item, but without telling the system to \"protect\" that range of data. This sudden appearance or disappearance is called a \"phantom\" read.\u003c/p\u003e\n\u003ch2\u003eRange Locks\u003c/h2\u003e\n\u003cp\u003eThink of locks as ways to protect data. There are different types of locks:\u003c/p\u003e\n\u003cp\u003e\n  \u003cstrong\u003eSerialized Access:\u003c/strong\u003e Only one task can use the data at a time. It's safe but slow.\n  \u003cstrong\u003eTable Lock:\u003c/strong\u003e Protects the whole table. Better speed, but can still be slow if many tasks want to write data.\n  \u003cstrong\u003eRow Lock:\u003c/strong\u003e Only locks a specific row of data. Faster, but tasks might wait if they need the same row.\n  \u003cstrong\u003eRange Locks:\u003c/strong\u003e These lock a group or \"range\" of data. They ensure no one adds or changes data in that range while you're working on it.\n\u003c/p\u003e\n\u003ch2\u003eIsolation Levels\u003c/h2\u003e\n\u003cp\u003e\n  SQL has 4 standard isolation levels to decide how data is accessed and protected during operations.\n  It's crucial to set a global standard for these levels to avoid unexpected behaviors.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eREPEATABLE READ:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  Think of it as taking a snapshot when you first read the data. Until you finish your task, that snapshot remains unchanged, even if others make changes.\n  It stops problems like seeing different data on multiple reads (non-repeatable reads) or accessing data that's still being edited by others (dirty reads).\n  However, to ensure data is always fresh, it's best to keep tasks brief.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSERIALIZABLE:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  It's like waiting in line. Only one task can work at a time, ensuring total consistency.\n  There's no chance of reading errors because each task finishes completely before the next one starts. But, tasks can sometimes fail\n  when too many try to run at once, so a system to try again (retry mechanism) is helpful.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eREAD COMMITTED:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  Unlike REPEATABLE READ, every time you read data, you get a new, updated view. This means you can sometimes read data that appears or disappears\n  suddenly (phantom reads) if you read multiple times in one task.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eREAD UNCOMMITTED:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  This is the wild west of isolation levels! You can access data even if someone else is still working on it. This can lead to reading half-finished\n  (dirty) data. Not ideal for systems needing accuracy.\n\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["databases","concurrency-and-locks"]},"buildId":"IjqNhIRqaAJaH2DY5dkbz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>