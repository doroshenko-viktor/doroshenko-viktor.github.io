<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Graphs</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/9fKbwg3D5HEktZ3M2RBfO/_buildManifest.js" defer=""></script><script src="/_next/static/9fKbwg3D5HEktZ3M2RBfO/_ssgManifest.js" defer=""></script><script src="/_next/static/9fKbwg3D5HEktZ3M2RBfO/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Graphs</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  <code>Graph</code> is a data structure, which models set of connections or edges. These connections generally may be not
  ordered like for array for example. Each node(also may be called vertices) in graph can have many connection to other nodes.
</p>
<p>Minimal requirement for graph - to have at least one node.</p>
<p>
  <img src="/_images/graphs-1.png" alt="graph example">
</p>
<p>
  While many data structures, like trees, tries, linked lists and many others are special cases of graphs
  and they have some root nodes, in general case graphs may not have any special root element, because
  there may be many non directional multiple connections between nodes.
</p>
<h2>Graph Direction</h2>
<p>Graphs may be undirected, directed or combined.</p>
<p>
  When graph is undirected means, that connection between two nodes can lead towards the second node and
  also backwards. Moreover to be called undirected graph all it's connections have to be undirected.
  Following example shows equivalent graphs:
</p>
<p>
  <img src="/_images/graphs-2.png" alt="non-directional graph">
</p>
<p>
  In directed graphs connection always links from one node to another, but opposite does not exist. And
  by analogy from undirected graphs, to be called <code>directed</code>, graph must have all edges to be directed.
</p>
<h2>Breadth First Search</h2>
<p>This is an algorithm, which allows to get an answer on two question regarding given graph;</p>
<ul>
  <li>Is there a way from node <code>A</code> to node <code>B</code></li>
  <li>Which is a shortest way from <code>A</code> to <code>B</code></li>
</ul>
<p>
  Consider following task. We have a graph with nodes of different colors. We need to find shortest way
  from red node to any orange node.
</p>
<p>
  <img src="/_images/graphs-3.png" alt="graph-bfs-example">
</p>
<p>
  To achieve that, we run simple algorithm. As a first step, we try to find orange node between nodes,
  which are linked with our initial red node. This is done by simple iteration through list of them.
  Red node with value <code>1</code> linked with nodes indexed <code>2</code>, <code>3</code> and <code>4</code>. Non of them is orange. Next we try
  to find orange nodes between relatives of <code>2</code>, <code>3</code> and <code>4</code>. Those nodes will be <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>,
  <code>10</code>, <code>11</code>. Node <code>11</code> is orange, which means our search is finished.
</p>
<p>
  As a result we not only found required orange node, but also this node has a shortest path to origin
  node, where we started our search. Note, that we have other orange nodes <code>12</code> and <code>13</code>, but they have
  longer path, so these nodes are not the answer.
</p>
<p>
  Other thing that should be highlighted - we have some nodes, which linked by more than one neighbor
  nodes, e.g. node <code>4</code> is linked by nodes <code>1</code> and <code>2</code>. This could be a problem. When we checked relatives
  of node <code>1</code> we check node <code>4</code>. Then, when there was no answer we go to relatives of node <code>2</code> which
  also points to node <code>4</code>. But we should not check it for the second time. This means, that we have to
  track, what nodes have already been checked. Not doing this not only inefficient, but also can lead to
  cycles. In this case search will not be finished at all.
</p>
<p>For example:</p>
<p>
  <img src="/_images/graphs-4.png" alt="bfs-cycle">
</p>
<p><code>1</code> points to <code>2</code>. <code>2</code> points to <code>3</code> and finally <code>3</code> points to <code>1</code>. Here we are in infinite loop.</p>
<h2>Plan</h2>
<p>
  Breadth First Search
  Dijkstra Algorithm
</p>
<h2>References</h2>
<h2>Next</h2>
<p>
  <a href="https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e">https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e</a>
  <a href="https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688">https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688</a>
  <a href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13">https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13</a>
  <a href="https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255">https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255</a>
  <a href="https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38">https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38</a>
</p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["algorithms","graphs"],"note":{"title":"Graphs","date":"2022-03-31","content":"\n\u003cp\u003e\n  \u003ccode\u003eGraph\u003c/code\u003e is a data structure, which models set of connections or edges. These connections generally may be not\n  ordered like for array for example. Each node(also may be called vertices) in graph can have many connection to other nodes.\n\u003c/p\u003e\n\u003cp\u003eMinimal requirement for graph - to have at least one node.\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg src=\"/_images/graphs-1.png\" alt=\"graph example\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  While many data structures, like trees, tries, linked lists and many others are special cases of graphs\n  and they have some root nodes, in general case graphs may not have any special root element, because\n  there may be many non directional multiple connections between nodes.\n\u003c/p\u003e\n\u003ch2\u003eGraph Direction\u003c/h2\u003e\n\u003cp\u003eGraphs may be undirected, directed or combined.\u003c/p\u003e\n\u003cp\u003e\n  When graph is undirected means, that connection between two nodes can lead towards the second node and\n  also backwards. Moreover to be called undirected graph all it's connections have to be undirected.\n  Following example shows equivalent graphs:\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg src=\"/_images/graphs-2.png\" alt=\"non-directional graph\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  In directed graphs connection always links from one node to another, but opposite does not exist. And\n  by analogy from undirected graphs, to be called \u003ccode\u003edirected\u003c/code\u003e, graph must have all edges to be directed.\n\u003c/p\u003e\n\u003ch2\u003eBreadth First Search\u003c/h2\u003e\n\u003cp\u003eThis is an algorithm, which allows to get an answer on two question regarding given graph;\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eIs there a way from node \u003ccode\u003eA\u003c/code\u003e to node \u003ccode\u003eB\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eWhich is a shortest way from \u003ccode\u003eA\u003c/code\u003e to \u003ccode\u003eB\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  Consider following task. We have a graph with nodes of different colors. We need to find shortest way\n  from red node to any orange node.\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg src=\"/_images/graphs-3.png\" alt=\"graph-bfs-example\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  To achieve that, we run simple algorithm. As a first step, we try to find orange node between nodes,\n  which are linked with our initial red node. This is done by simple iteration through list of them.\n  Red node with value \u003ccode\u003e1\u003c/code\u003e linked with nodes indexed \u003ccode\u003e2\u003c/code\u003e, \u003ccode\u003e3\u003c/code\u003e and \u003ccode\u003e4\u003c/code\u003e. Non of them is orange. Next we try\n  to find orange nodes between relatives of \u003ccode\u003e2\u003c/code\u003e, \u003ccode\u003e3\u003c/code\u003e and \u003ccode\u003e4\u003c/code\u003e. Those nodes will be \u003ccode\u003e5\u003c/code\u003e, \u003ccode\u003e6\u003c/code\u003e, \u003ccode\u003e7\u003c/code\u003e, \u003ccode\u003e8\u003c/code\u003e, \u003ccode\u003e9\u003c/code\u003e,\n  \u003ccode\u003e10\u003c/code\u003e, \u003ccode\u003e11\u003c/code\u003e. Node \u003ccode\u003e11\u003c/code\u003e is orange, which means our search is finished.\n\u003c/p\u003e\n\u003cp\u003e\n  As a result we not only found required orange node, but also this node has a shortest path to origin\n  node, where we started our search. Note, that we have other orange nodes \u003ccode\u003e12\u003c/code\u003e and \u003ccode\u003e13\u003c/code\u003e, but they have\n  longer path, so these nodes are not the answer.\n\u003c/p\u003e\n\u003cp\u003e\n  Other thing that should be highlighted - we have some nodes, which linked by more than one neighbor\n  nodes, e.g. node \u003ccode\u003e4\u003c/code\u003e is linked by nodes \u003ccode\u003e1\u003c/code\u003e and \u003ccode\u003e2\u003c/code\u003e. This could be a problem. When we checked relatives\n  of node \u003ccode\u003e1\u003c/code\u003e we check node \u003ccode\u003e4\u003c/code\u003e. Then, when there was no answer we go to relatives of node \u003ccode\u003e2\u003c/code\u003e which\n  also points to node \u003ccode\u003e4\u003c/code\u003e. But we should not check it for the second time. This means, that we have to\n  track, what nodes have already been checked. Not doing this not only inefficient, but also can lead to\n  cycles. In this case search will not be finished at all.\n\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg src=\"/_images/graphs-4.png\" alt=\"bfs-cycle\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e1\u003c/code\u003e points to \u003ccode\u003e2\u003c/code\u003e. \u003ccode\u003e2\u003c/code\u003e points to \u003ccode\u003e3\u003c/code\u003e and finally \u003ccode\u003e3\u003c/code\u003e points to \u003ccode\u003e1\u003c/code\u003e. Here we are in infinite loop.\u003c/p\u003e\n\u003ch2\u003ePlan\u003c/h2\u003e\n\u003cp\u003e\n  Breadth First Search\n  Dijkstra Algorithm\n\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003ch2\u003eNext\u003c/h2\u003e\n\u003cp\u003e\n  \u003ca href=\"https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e\"\u003ehttps://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e\u003c/a\u003e\n  \u003ca href=\"https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688\"\u003ehttps://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688\u003c/a\u003e\n  \u003ca href=\"https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13\"\u003ehttps://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13\u003c/a\u003e\n  \u003ca href=\"https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255\"\u003ehttps://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255\u003c/a\u003e\n  \u003ca href=\"https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38\"\u003ehttps://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38\u003c/a\u003e\n\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["algorithms","graphs"]},"buildId":"9fKbwg3D5HEktZ3M2RBfO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>