<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Rust Async Programming</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/9i1uunajO0N4S3BLo8eVG/_buildManifest.js" defer=""></script><script src="/_next/static/9i1uunajO0N4S3BLo8eVG/_ssgManifest.js" defer=""></script><script src="/_next/static/9i1uunajO0N4S3BLo8eVG/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Rust Async Programming</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  <code>Asynchronous programming</code> is a concurrency model, which allows to multiple independent tasks to
  operate on base of smaller number of OS threads. It allows to greatly reduce workload in some
  scenarios, like with heavy usage of <code>IO</code> operations. In this case if we use OS threads, means that
  on each <code>IO</code> operation, thread will simply wait for it's completion, while in <code>async</code> model it can
  resume it's work on another task. That allows smaller number of OS threads to do the same work,
  saving a lot of performance on context switching.
</p>
<p>Particularly in Rust it is worth to always keep in mind, that:</p>
<ul>
  <li>
    <code>Futures</code> (also known as <code>Tasks</code> in C# or <code>Promises</code> in JS languages) start doing their action
    only whence actively triggered and they stop execution, when go out of scope and dropped.
  </li>
  <li>
    Unlike other languages, Rust does not provide a runtime for <code>async</code> operations for performance
    reasons. Custom <code>async</code> runtimes are provided by community. They can be single-threaded, like <code>V8</code>
    in JS world or multithreaded.
  </li>
</ul>
<p>
  Rust natively provides <code>Future</code> trait and <code>async/await</code> keywords, some utility types in <code>futures</code>
  crate. Other functionality can be used added by third party modules.
</p>
<h2>Async / Await</h2>
<p><code>async/await</code> syntax allows to some blocks of code to return control on the thread instead of blocking.</p>
<p><code>async</code> may be used on functions and blocks:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>() <span class="hljs-punctuation">-></span> <span class="hljs-type">i32</span> { 
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>or</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>
  <code>async</code> block or function return <code>Future</code>, which will not run on fact of creation, it must be
  triggered. To do so we can use <code>.await</code> method. After call of <code>.await</code> future is trying to complete
  it's instructions, but if at some point it will be blocked, it will return control on thread it's
  operating on. After blocking code will be ready, execution environment will return control on some
  thread to the <code>Future</code> allowing to finish it's execution.
</p>
<p>If the <code>Future</code> accepts some parameters with non <code>'static</code> lifetime, it will be bound to their lifetime.</p>
<p>To transform <code>Future</code> with custom lifetime reference to a <code>'static</code> lifetime there are some ways.</p>
<p>Using <code>async</code> blocks:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bad</span>() <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&#x3C;Output = <span class="hljs-type">u8</span>> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;
    <span class="hljs-title function_ invoke__">borrow_x</span>(&#x26;x) <span class="hljs-comment">// ERROR: `x` does not live long enough</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">good</span>() <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&#x3C;Output = <span class="hljs-type">u8</span>> {
    <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;
        <span class="hljs-title function_ invoke__">borrow_x</span>(&#x26;x).<span class="hljs-keyword">await</span>
    }
}
</code></pre>
<p>
  Using <code>move</code> it is possible to give an ownership on some variables to the <code>Future</code> allowing them to
  live more that outer context:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">blocks</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">my_string</span> = <span class="hljs-string">"foo"</span>.<span class="hljs-title function_ invoke__">to_string</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">future_one</span> = <span class="hljs-keyword">async</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{my_string}"</span>);
    };

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">future_two</span> = <span class="hljs-keyword">async</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{my_string}"</span>);
    };

    <span class="hljs-comment">// Run both futures to completion, printing "foo" twice:</span>
    <span class="hljs-keyword">let</span> ((), ()) = futures::join!(future_one, future_two);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">move_block</span>() <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&#x3C;Output = ()> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">my_string</span> = <span class="hljs-string">"foo"</span>.<span class="hljs-title function_ invoke__">to_string</span>();
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{my_string}"</span>);
    }
}
</code></pre>
<h2>Stream</h2>
<p>
  <code>Stream</code> trait allows to emit multiple values before completion. It is like a combination of <code>Future</code>
  and <code>Iterator</code>. For example <code>Receiver</code> for the channel type from the futures crate. It will yield <code>Some(val)</code> every time a value is sent from the <code>Sender</code> end, and will yield <code>None</code> once the <code>Sender</code> has been dropped and all pending messages have been received:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send_recv</span>() {
    <span class="hljs-keyword">const</span> BUFFER_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> tx, <span class="hljs-keyword">mut</span> rx) = mpsc::channel::&#x3C;<span class="hljs-type">i32</span>>(BUFFER_SIZE);

    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();
    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-title function_ invoke__">drop</span>(tx);

    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);
}
</code></pre>
<p>
  It is possible to iterate on <code>Stream</code> like on <code>Iterator</code> with <code>map</code>, <code>filter</code>, <code>fold</code>, <code>try_map</code>, <code>try_filter</code> and <code>try_fold</code> as well as with <code>while let</code> loop. But it is not possible to use <code>for</code>
  loop with a <code>Stream</code>.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum_with_next</span>(<span class="hljs-keyword">mut</span> stream: Pin&#x3C;&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&#x3C;Item = <span class="hljs-type">i32</span>>>) <span class="hljs-punctuation">-></span> <span class="hljs-type">i32</span> {
    <span class="hljs-keyword">use</span> futures::stream::StreamExt; <span class="hljs-comment">// for `next`</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>(item) = stream.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span> {
        sum += item;
    }
    sum
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum_with_try_next</span>(
    <span class="hljs-keyword">mut</span> stream: Pin&#x3C;&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&#x3C;Item = <span class="hljs-type">Result</span>&#x3C;<span class="hljs-type">i32</span>, io::Error>>>,
) <span class="hljs-punctuation">-></span> <span class="hljs-type">Result</span>&#x3C;<span class="hljs-type">i32</span>, io::Error> {
    <span class="hljs-keyword">use</span> futures::stream::TryStreamExt; <span class="hljs-comment">// for `try_next`</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>(item) = stream.<span class="hljs-title function_ invoke__">try_next</span>().<span class="hljs-keyword">await</span>? {
        sum += item;
    }
    <span class="hljs-title function_ invoke__">Ok</span>(sum)
}
</code></pre>
<p>To iterate concurrently:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">jump_around</span>(
    <span class="hljs-keyword">mut</span> stream: Pin&#x3C;&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&#x3C;Item = <span class="hljs-type">Result</span>&#x3C;<span class="hljs-type">u8</span>, io::Error>>>,
) <span class="hljs-punctuation">-></span> <span class="hljs-type">Result</span>&#x3C;(), io::Error> {
    <span class="hljs-keyword">use</span> futures::stream::TryStreamExt; <span class="hljs-comment">// for `try_for_each_concurrent`</span>
    <span class="hljs-keyword">const</span> MAX_CONCURRENT_JUMPERS: <span class="hljs-type">usize</span> = <span class="hljs-number">100</span>;

    stream.<span class="hljs-title function_ invoke__">try_for_each_concurrent</span>(MAX_CONCURRENT_JUMPERS, |num| <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
        <span class="hljs-title function_ invoke__">jump_n_times</span>(num).<span class="hljs-keyword">await</span>?;
        <span class="hljs-title function_ invoke__">report_n_jumps</span>(num).<span class="hljs-keyword">await</span>?;
        <span class="hljs-title function_ invoke__">Ok</span>(())
    }).<span class="hljs-keyword">await</span>?;

    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<h2>Joining <code>Futures</code></h2>
<p>
  Unlike other languages, where it is possible to run several async tasks and after that await for
  them all, in Rust this is not possible, because <code>Future</code> does not start to execute upon creation.
  But if we will try to create several <code>Futures</code> one after another and await them they will execute
  sequentially and not concurrently.
</p>
<p>
  When we run multiple <code>Futures</code> concurrently and need to wait until each of them will be completed,
  we can use <code>futures::join</code> macro.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> futures::join;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book_and_music</span>() <span class="hljs-punctuation">-></span> (Book, Music) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">get_book</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">get_music</span>();
    join!(book_fut, music_fut)
}
</code></pre>
<p>
  This allows for two <code>Futures</code> to be executed in parallel. <code>join</code> returns tuple with results of
  all <code>Futures</code> passed into it.
</p>
<p>
  If concurrent <code>Futures</code> return <code>Result&#x3C;T></code> it may be useful to use <code>try_join</code>. It will stop execution,
  if some of the futures returned an error result.
</p>
<p>All futures must have the same error type. To achieve this <code>.map_err(|e| ...)</code> and <code>.err_into()</code> functions from <code>futures::future::TryFutureExt</code> would be useful.</p>
<h2>Select</h2>
<p>
  When running multiple <code>Futures</code> concurrently we need to wait only for the first completed of them,
  we can use <a href="https://rust-lang.github.io/async-book/06_multiple_futures/03_select.html"><code>futures::select</code></a> macro:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> futures::{
    future::FutureExt, <span class="hljs-comment">// for `.fuse()`</span>
    pin_mut,
    select,
};

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_one</span>() { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_two</span>() { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">race_tasks</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">t1</span> = <span class="hljs-title function_ invoke__">task_one</span>().<span class="hljs-title function_ invoke__">fuse</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">t2</span> = <span class="hljs-title function_ invoke__">task_two</span>().<span class="hljs-title function_ invoke__">fuse</span>();

    pin_mut!(t1, t2);

    <span class="hljs-built_in">select!</span> {
        () = t1 => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"task one completed first"</span>),
        () = t2 => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"task two completed first"</span>),
    }
}
</code></pre>
<p>When first <code>Future</code> completes, all other stop their execution.</p>
<p>The basic syntax for <code>select</code> is <code>&#x3C;pattern> = &#x3C;expression> => &#x3C;code>,</code></p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["rust","Concurrency","async-programming"],"note":{"title":"Rust Async Programming","date":"2022-06-02","content":"\n\u003cp\u003e\n  \u003ccode\u003eAsynchronous programming\u003c/code\u003e is a concurrency model, which allows to multiple independent tasks to\n  operate on base of smaller number of OS threads. It allows to greatly reduce workload in some\n  scenarios, like with heavy usage of \u003ccode\u003eIO\u003c/code\u003e operations. In this case if we use OS threads, means that\n  on each \u003ccode\u003eIO\u003c/code\u003e operation, thread will simply wait for it's completion, while in \u003ccode\u003easync\u003c/code\u003e model it can\n  resume it's work on another task. That allows smaller number of OS threads to do the same work,\n  saving a lot of performance on context switching.\n\u003c/p\u003e\n\u003cp\u003eParticularly in Rust it is worth to always keep in mind, that:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    \u003ccode\u003eFutures\u003c/code\u003e (also known as \u003ccode\u003eTasks\u003c/code\u003e in C# or \u003ccode\u003ePromises\u003c/code\u003e in JS languages) start doing their action\n    only whence actively triggered and they stop execution, when go out of scope and dropped.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Unlike other languages, Rust does not provide a runtime for \u003ccode\u003easync\u003c/code\u003e operations for performance\n    reasons. Custom \u003ccode\u003easync\u003c/code\u003e runtimes are provided by community. They can be single-threaded, like \u003ccode\u003eV8\u003c/code\u003e\n    in JS world or multithreaded.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  Rust natively provides \u003ccode\u003eFuture\u003c/code\u003e trait and \u003ccode\u003easync/await\u003c/code\u003e keywords, some utility types in \u003ccode\u003efutures\u003c/code\u003e\n  crate. Other functionality can be used added by third party modules.\n\u003c/p\u003e\n\u003ch2\u003eAsync / Await\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003easync/await\u003c/code\u003e syntax allows to some blocks of code to return control on the thread instead of blocking.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e may be used on functions and blocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esome_function\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e { \n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  \u003ccode\u003easync\u003c/code\u003e block or function return \u003ccode\u003eFuture\u003c/code\u003e, which will not run on fact of creation, it must be\n  triggered. To do so we can use \u003ccode\u003e.await\u003c/code\u003e method. After call of \u003ccode\u003e.await\u003c/code\u003e future is trying to complete\n  it's instructions, but if at some point it will be blocked, it will return control on thread it's\n  operating on. After blocking code will be ready, execution environment will return control on some\n  thread to the \u003ccode\u003eFuture\u003c/code\u003e allowing to finish it's execution.\n\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003eFuture\u003c/code\u003e accepts some parameters with non \u003ccode\u003e'static\u003c/code\u003e lifetime, it will be bound to their lifetime.\u003c/p\u003e\n\u003cp\u003eTo transform \u003ccode\u003eFuture\u003c/code\u003e with custom lifetime reference to a \u003ccode\u003e'static\u003c/code\u003e lifetime there are some ways.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003easync\u003c/code\u003e blocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebad\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;Output = \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eborrow_x\u003c/span\u003e(\u0026#x26;x) \u003cspan class=\"hljs-comment\"\u003e// ERROR: `x` does not live long enough\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egood\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;Output = \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eborrow_x\u003c/span\u003e(\u0026#x26;x).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Using \u003ccode\u003emove\u003c/code\u003e it is possible to give an ownership on some variables to the \u003ccode\u003eFuture\u003c/code\u003e allowing them to\n  live more that outer context:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eblocks\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003emy_string\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003efuture_one\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{my_string}\"\u003c/span\u003e);\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003efuture_two\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{my_string}\"\u003c/span\u003e);\n    };\n\n    \u003cspan class=\"hljs-comment\"\u003e// Run both futures to completion, printing \"foo\" twice:\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ((), ()) = futures::join!(future_one, future_two);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emove_block\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;Output = ()\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003emy_string\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{my_string}\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eStream\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003eStream\u003c/code\u003e trait allows to emit multiple values before completion. It is like a combination of \u003ccode\u003eFuture\u003c/code\u003e\n  and \u003ccode\u003eIterator\u003c/code\u003e. For example \u003ccode\u003eReceiver\u003c/code\u003e for the channel type from the futures crate. It will yield \u003ccode\u003eSome(val)\u003c/code\u003e every time a value is sent from the \u003ccode\u003eSender\u003c/code\u003e end, and will yield \u003ccode\u003eNone\u003c/code\u003e once the \u003ccode\u003eSender\u003c/code\u003e has been dropped and all pending messages have been received:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esend_recv\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e BUFFER_SIZE: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e tx, \u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e rx) = mpsc::channel::\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e\u003e(BUFFER_SIZE);\n\n    tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003edrop\u003c/span\u003e(tx);\n\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(\u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), rx.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(\u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), rx.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert_eq!\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, rx.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  It is possible to iterate on \u003ccode\u003eStream\u003c/code\u003e like on \u003ccode\u003eIterator\u003c/code\u003e with \u003ccode\u003emap\u003c/code\u003e, \u003ccode\u003efilter\u003c/code\u003e, \u003ccode\u003efold\u003c/code\u003e, \u003ccode\u003etry_map\u003c/code\u003e, \u003ccode\u003etry_filter\u003c/code\u003e and \u003ccode\u003etry_fold\u003c/code\u003e as well as with \u003ccode\u003ewhile let\u003c/code\u003e loop. But it is not possible to use \u003ccode\u003efor\u003c/code\u003e\n  loop with a \u003ccode\u003eStream\u003c/code\u003e.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esum_with_next\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e stream: Pin\u0026#x3C;\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e Stream\u0026#x3C;Item = \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e\u003e\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e futures::stream::StreamExt; \u003cspan class=\"hljs-comment\"\u003e// for `next`\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003esum\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(item) = stream.\u003cspan class=\"hljs-title function_ invoke__\"\u003enext\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e {\n        sum += item;\n    }\n    sum\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esum_with_try_next\u003c/span\u003e(\n    \u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e stream: Pin\u0026#x3C;\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e Stream\u0026#x3C;Item = \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e, io::Error\u003e\u003e\u003e,\n) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e, io::Error\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e futures::stream::TryStreamExt; \u003cspan class=\"hljs-comment\"\u003e// for `try_next`\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003esum\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(item) = stream.\u003cspan class=\"hljs-title function_ invoke__\"\u003etry_next\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e? {\n        sum += item;\n    }\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eOk\u003c/span\u003e(sum)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo iterate concurrently:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejump_around\u003c/span\u003e(\n    \u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e stream: Pin\u0026#x3C;\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e Stream\u0026#x3C;Item = \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e, io::Error\u003e\u003e\u003e,\n) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;(), io::Error\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e futures::stream::TryStreamExt; \u003cspan class=\"hljs-comment\"\u003e// for `try_for_each_concurrent`\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MAX_CONCURRENT_JUMPERS: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n\n    stream.\u003cspan class=\"hljs-title function_ invoke__\"\u003etry_for_each_concurrent\u003c/span\u003e(MAX_CONCURRENT_JUMPERS, |num| \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003ejump_n_times\u003c/span\u003e(num).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e?;\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003ereport_n_jumps\u003c/span\u003e(num).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e?;\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eOk\u003c/span\u003e(())\n    }).\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e?;\n\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eOk\u003c/span\u003e(())\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eJoining \u003ccode\u003eFutures\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\n  Unlike other languages, where it is possible to run several async tasks and after that await for\n  them all, in Rust this is not possible, because \u003ccode\u003eFuture\u003c/code\u003e does not start to execute upon creation.\n  But if we will try to create several \u003ccode\u003eFutures\u003c/code\u003e one after another and await them they will execute\n  sequentially and not concurrently.\n\u003c/p\u003e\n\u003cp\u003e\n  When we run multiple \u003ccode\u003eFutures\u003c/code\u003e concurrently and need to wait until each of them will be completed,\n  we can use \u003ccode\u003efutures::join\u003c/code\u003e macro.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e futures::join;\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_book_and_music\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e (Book, Music) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ebook_fut\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_book\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003emusic_fut\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eget_music\u003c/span\u003e();\n    join!(book_fut, music_fut)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  This allows for two \u003ccode\u003eFutures\u003c/code\u003e to be executed in parallel. \u003ccode\u003ejoin\u003c/code\u003e returns tuple with results of\n  all \u003ccode\u003eFutures\u003c/code\u003e passed into it.\n\u003c/p\u003e\n\u003cp\u003e\n  If concurrent \u003ccode\u003eFutures\u003c/code\u003e return \u003ccode\u003eResult\u0026#x3C;T\u003e\u003c/code\u003e it may be useful to use \u003ccode\u003etry_join\u003c/code\u003e. It will stop execution,\n  if some of the futures returned an error result.\n\u003c/p\u003e\n\u003cp\u003eAll futures must have the same error type. To achieve this \u003ccode\u003e.map_err(|e| ...)\u003c/code\u003e and \u003ccode\u003e.err_into()\u003c/code\u003e functions from \u003ccode\u003efutures::future::TryFutureExt\u003c/code\u003e would be useful.\u003c/p\u003e\n\u003ch2\u003eSelect\u003c/h2\u003e\n\u003cp\u003e\n  When running multiple \u003ccode\u003eFutures\u003c/code\u003e concurrently we need to wait only for the first completed of them,\n  we can use \u003ca href=\"https://rust-lang.github.io/async-book/06_multiple_futures/03_select.html\"\u003e\u003ccode\u003efutures::select\u003c/code\u003e\u003c/a\u003e macro:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e futures::{\n    future::FutureExt, \u003cspan class=\"hljs-comment\"\u003e// for `.fuse()`\u003c/span\u003e\n    pin_mut,\n    select,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etask_one\u003c/span\u003e() { \u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etask_two\u003c/span\u003e() { \u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e }\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erace_tasks\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003et1\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003etask_one\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efuse\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003et2\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003etask_two\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efuse\u003c/span\u003e();\n\n    pin_mut!(t1, t2);\n\n    \u003cspan class=\"hljs-built_in\"\u003eselect!\u003c/span\u003e {\n        () = t1 =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"task one completed first\"\u003c/span\u003e),\n        () = t2 =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"task two completed first\"\u003c/span\u003e),\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen first \u003ccode\u003eFuture\u003c/code\u003e completes, all other stop their execution.\u003c/p\u003e\n\u003cp\u003eThe basic syntax for \u003ccode\u003eselect\u003c/code\u003e is \u003ccode\u003e\u0026#x3C;pattern\u003e = \u0026#x3C;expression\u003e =\u003e \u0026#x3C;code\u003e,\u003c/code\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["rust","Concurrency","async-programming"]},"buildId":"9i1uunajO0N4S3BLo8eVG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>