<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Rust - Pattern Matching</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_buildManifest.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_ssgManifest.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Rust - Pattern Matching</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  Pattern matching in Rust implemented with <code>match</code> statement, which contains list of pattern to
  expression pairs called <code>arms</code>.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">match</span> VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
</code></pre>
<p>
  <code>match</code> arms must contain all possible variants of execution. There will be a compilation error
  if there is some case of exectution which not specified as a <code>match</code> arm.
</p>
<p>
  One solution to use <code>_</code> pattern, which allows to gather all possible variants, not specified
  directly.
</p>
<h2>if let</h2>
<p>Another solution for situations when we need to catch only one pattern case is to use <code>if let</code> construct.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">favorite_color</span>: <span class="hljs-type">Option</span>&#x3C;&#x26;<span class="hljs-type">str</span>> = <span class="hljs-literal">None</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">is_tuesday</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">age</span>: <span class="hljs-type">Result</span>&#x3C;<span class="hljs-type">u8</span>, _> = <span class="hljs-string">"34"</span>.<span class="hljs-title function_ invoke__">parse</span>();

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>(color) = favorite_color {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Using your favorite color, {}, as the background"</span>, color);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> is_tuesday {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Tuesday is green day!"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Ok</span>(age) = age {
        <span class="hljs-keyword">if</span> age > <span class="hljs-number">30</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Using purple as the background color"</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Using orange as the background color"</span>);
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Using blue as the background color"</span>);
    }
}
</code></pre>
<p>
  Here important to notice, that <code>let if</code> as well as <code>match</code> can create shadowing varable, like in
  line <code>} else if let Ok(age) = age {</code>. This means that further <code>if age > 30</code> has the value from <code>Ok(age)</code>
  and not original <code>age</code>. And also this means that it is not possible to use age this way:
  <code>} else if let Ok(age) = age &#x26;&#x26; age > 30{</code>.
</p>
<h2>while let</h2>
<p>This expression is sililar to <code>if let</code>, but here <code>while</code> loop will run until pattern is matching.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();

stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);
stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);
stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);

<span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>(top) = stack.<span class="hljs-title function_ invoke__">pop</span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, top);
}
</code></pre>
<h2>for</h2>
<p>
  <code>for</code> loop in Rust also uses pattern matching. In particular, expression, following <code>for</code> keyword
  is a pattern.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];

<span class="hljs-title function_ invoke__">for</span> (index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} is at index {}"</span>, value, index);
}
</code></pre>
<h2>let</h2>
<p>
  Assignment in Rust is also a pattern. For example: <code>let x = 5;</code> is <code>let PATTERN = EXPRESSION;</code>.
  Example, <code>x</code> is a pattern that means “bind what matches here to the variable x.” Because the name
  <code>x</code> is the whole pattern, this pattern effectively means “bind everything to the variable <code>x</code>,
  whatever the value is.”
</p>
<p>More complex example of it:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> (x, y, z) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<p>Functional parameters also may be patterns:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_coordinates</span>(&#x26;(x, y): &#x26;(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Current location: ({}, {})"</span>, x, y);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">point</span> = (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
    <span class="hljs-title function_ invoke__">print_coordinates</span>(&#x26;point);
}
</code></pre>
<p><strong>Matching literals:</strong></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;

<span class="hljs-keyword">match</span> x {
    <span class="hljs-number">1</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one"</span>),
    <span class="hljs-number">2</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"two"</span>),
    <span class="hljs-number">3</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"three"</span>),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"anything"</span>),
}
</code></pre>
<p><strong>Matching Named Variables:</strong></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;

<span class="hljs-keyword">match</span> x {
    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">50</span>) => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Got 50"</span>),
    <span class="hljs-title function_ invoke__">Some</span>(y) => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Matched, y = {:?}"</span>, y),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Default case, x = {:?}"</span>, x),
}

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"at the end: x = {:?}, y = {:?}"</span>, x, y);
</code></pre>
<p><strong>Matching Multiple Patterns:</strong></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;

<span class="hljs-keyword">match</span> {
    <span class="hljs-number">1</span> | <span class="hljs-number">2</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one or two"</span>),
    <span class="hljs-number">3</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"three"</span>),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"anything"</span>),
}
</code></pre>
<p><strong>Matching Ranges:</strong></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;

<span class="hljs-keyword">match</span> x {
    <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one through five"</span>),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"something else"</span>),
}
</code></pre>
<p>
  Ranges are only allowed with numeric values or char values, because the compiler checks that the
  range isn’t empty at compile time.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-string">'c'</span>;

<span class="hljs-keyword">match</span> x {
    <span class="hljs-string">'a'</span>..=<span class="hljs-string">'j'</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"early ASCII letter"</span>),
    <span class="hljs-string">'k'</span>..=<span class="hljs-string">'z'</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"late ASCII letter"</span>),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"something else"</span>),
}
</code></pre>
<h2>Conditional Pattern Matching</h2>
<p><code>match</code> also supprts additional conditions:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>);

<span class="hljs-keyword">match</span> num {
    <span class="hljs-title function_ invoke__">Some</span>(x) <span class="hljs-keyword">if</span> x &#x3C; <span class="hljs-number">5</span> => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"less than five: {}"</span>, x),
    <span class="hljs-title function_ invoke__">Some</span>(x) => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x),
    <span class="hljs-literal">None</span> => (),
}
</code></pre>
<p>
  Extra condition also solves shadowing problem, when <code>match</code> creates new variable with same name
  which can hide external scope variable:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;

    <span class="hljs-keyword">match</span> x {
        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">50</span>) => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Got 50"</span>),
        <span class="hljs-title function_ invoke__">Some</span>(n) <span class="hljs-keyword">if</span> n == y => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Matched, n = {}"</span>, n),
        _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Default case, x = {:?}"</span>, x),
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"at the end: x = {:?}, y = {}"</span>, x, y);
}
</code></pre>
<p>With <code>|</code> operator:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">y</span> = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">match</span> x {
    <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> <span class="hljs-keyword">if</span> y => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"yes"</span>),
    _ => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"no"</span>),
}
</code></pre>
<h2>@ operator</h2>
<p><code>@</code> allows to create new variable and test it on some pattern, but use it after in matched block:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> {
    Hello { id: <span class="hljs-type">i32</span> },
}

<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">msg</span> = Message::Hello { id: <span class="hljs-number">5</span> };

<span class="hljs-keyword">match</span> msg {
    Message::Hello {
        id: id_variable @ <span class="hljs-number">3</span>..=<span class="hljs-number">7</span>,
    } => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Found an id in range: {}"</span>, id_variable),
    Message::Hello { id: <span class="hljs-number">10</span>..=<span class="hljs-number">12</span> } => {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Found an id in another range"</span>)
    }
    Message::Hello { id } => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Found some other id: {}"</span>, id),
}
</code></pre>
<h2>References</h2>
<ul>
  <li><a href="https://doc.rust-lang.org/stable/book/ch18-01-all-the-places-for-patterns.html">Rust Book - Pattern Matching</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["rust","pattern-matching"],"note":{"title":"Rust - Pattern Matching","date":"2022-03-11","content":"\n\u003cp\u003e\n  Pattern matching in Rust implemented with \u003ccode\u003ematch\u003c/code\u003e statement, which contains list of pattern to\n  expression pairs called \u003ccode\u003earms\u003c/code\u003e.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e VALUE {\n    PATTERN =\u003e EXPRESSION,\n    PATTERN =\u003e EXPRESSION,\n    PATTERN =\u003e EXPRESSION,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  \u003ccode\u003ematch\u003c/code\u003e arms must contain all possible variants of execution. There will be a compilation error\n  if there is some case of exectution which not specified as a \u003ccode\u003ematch\u003c/code\u003e arm.\n\u003c/p\u003e\n\u003cp\u003e\n  One solution to use \u003ccode\u003e_\u003c/code\u003e pattern, which allows to gather all possible variants, not specified\n  directly.\n\u003c/p\u003e\n\u003ch2\u003eif let\u003c/h2\u003e\n\u003cp\u003eAnother solution for situations when we need to catch only one pattern case is to use \u003ccode\u003eif let\u003c/code\u003e construct.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003efavorite_color\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;\u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e\u003e = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eis_tuesday\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e, _\u003e = \u003cspan class=\"hljs-string\"\u003e\"34\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eparse\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(color) = favorite_color {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Using your favorite color, {}, as the background\"\u003c/span\u003e, color);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e is_tuesday {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Tuesday is green day!\"\u003c/span\u003e);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eOk\u003c/span\u003e(age) = age {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e age \u003e \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Using purple as the background color\"\u003c/span\u003e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Using orange as the background color\"\u003c/span\u003e);\n        }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Using blue as the background color\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Here important to notice, that \u003ccode\u003elet if\u003c/code\u003e as well as \u003ccode\u003ematch\u003c/code\u003e can create shadowing varable, like in\n  line \u003ccode\u003e} else if let Ok(age) = age {\u003c/code\u003e. This means that further \u003ccode\u003eif age \u003e 30\u003c/code\u003e has the value from \u003ccode\u003eOk(age)\u003c/code\u003e\n  and not original \u003ccode\u003eage\u003c/code\u003e. And also this means that it is not possible to use age this way:\n  \u003ccode\u003e} else if let Ok(age) = age \u0026#x26;\u0026#x26; age \u003e 30{\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch2\u003ewhile let\u003c/h2\u003e\n\u003cp\u003eThis expression is sililar to \u003ccode\u003eif let\u003c/code\u003e, but here \u003ccode\u003ewhile\u003c/code\u003e loop will run until pattern is matching.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003estack\u003c/span\u003e = Vec::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e();\n\nstack.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\nstack.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\nstack.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(top) = stack.\u003cspan class=\"hljs-title function_ invoke__\"\u003epop\u003c/span\u003e() {\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, top);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003efor\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003efor\u003c/code\u003e loop in Rust also uses pattern matching. In particular, expression, following \u003ccode\u003efor\u003c/code\u003e keyword\n  is a pattern.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ev\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e];\n\n\u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (index, value) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e v.\u003cspan class=\"hljs-title function_ invoke__\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eenumerate\u003c/span\u003e() {\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{} is at index {}\"\u003c/span\u003e, value, index);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003elet\u003c/h2\u003e\n\u003cp\u003e\n  Assignment in Rust is also a pattern. For example: \u003ccode\u003elet x = 5;\u003c/code\u003e is \u003ccode\u003elet PATTERN = EXPRESSION;\u003c/code\u003e.\n  Example, \u003ccode\u003ex\u003c/code\u003e is a pattern that means “bind what matches here to the variable x.” Because the name\n  \u003ccode\u003ex\u003c/code\u003e is the whole pattern, this pattern effectively means “bind everything to the variable \u003ccode\u003ex\u003c/code\u003e,\n  whatever the value is.”\n\u003c/p\u003e\n\u003cp\u003eMore complex example of it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (x, y, z) = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctional parameters also may be patterns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint_coordinates\u003c/span\u003e(\u0026#x26;(x, y): \u0026#x26;(\u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Current location: ({}, {})\"\u003c/span\u003e, x, y);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003epoint\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eprint_coordinates\u003c/span\u003e(\u0026#x26;point);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMatching literals:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"one\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"two\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"three\"\u003c/span\u003e),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"anything\"\u003c/span\u003e),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMatching Named Variables:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ey\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Got 50\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(y) =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Matched, y = {:?}\"\u003c/span\u003e, y),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Default case, x = {:?}\"\u003c/span\u003e, x),\n}\n\n\u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"at the end: x = {:?}, y = {:?}\"\u003c/span\u003e, x, y);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMatching Multiple Patterns:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e {\n    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e | \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"one or two\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"three\"\u003c/span\u003e),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"anything\"\u003c/span\u003e),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMatching Ranges:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e..=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"one through five\"\u003c/span\u003e),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"something else\"\u003c/span\u003e),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Ranges are only allowed with numeric values or char values, because the compiler checks that the\n  range isn’t empty at compile time.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n    \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e..=\u003cspan class=\"hljs-string\"\u003e'j'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"early ASCII letter\"\u003c/span\u003e),\n    \u003cspan class=\"hljs-string\"\u003e'k'\u003c/span\u003e..=\u003cspan class=\"hljs-string\"\u003e'z'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"late ASCII letter\"\u003c/span\u003e),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"something else\"\u003c/span\u003e),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eConditional Pattern Matching\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ematch\u003c/code\u003e also supprts additional conditions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003enum\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e num {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(x) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"less than five: {}\"\u003c/span\u003e, x),\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(x) =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, x),\n    \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e =\u003e (),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Extra condition also solves shadowing problem, when \u003ccode\u003ematch\u003c/code\u003e creates new variable with same name\n  which can hide external scope variable:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ey\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Got 50\"\u003c/span\u003e),\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(n) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e n == y =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Matched, n = {}\"\u003c/span\u003e, n),\n        _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Default case, x = {:?}\"\u003c/span\u003e, x),\n    }\n\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"at the end: x = {:?}, y = {}\"\u003c/span\u003e, x, y);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith \u003ccode\u003e|\u003c/code\u003e operator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ey\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e x {\n    \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e | \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e | \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e y =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"yes\"\u003c/span\u003e),\n    _ =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"no\"\u003c/span\u003e),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e@ operator\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e allows to create new variable and test it on some pattern, but use it after in matched block:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e {\n    Hello { id: \u003cspan class=\"hljs-type\"\u003ei32\u003c/span\u003e },\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003emsg\u003c/span\u003e = Message::Hello { id: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e msg {\n    Message::Hello {\n        id: id_variable @ \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e..=\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\n    } =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Found an id in range: {}\"\u003c/span\u003e, id_variable),\n    Message::Hello { id: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e..=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e } =\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Found an id in another range\"\u003c/span\u003e)\n    }\n    Message::Hello { id } =\u003e \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Found some other id: {}\"\u003c/span\u003e, id),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://doc.rust-lang.org/stable/book/ch18-01-all-the-places-for-patterns.html\"\u003eRust Book - Pattern Matching\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["rust","pattern-matching"]},"buildId":"rEbIxoA2O-xiW5DUZwlG8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>