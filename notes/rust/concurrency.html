<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Rust Concurrency</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_buildManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_ssgManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Rust Concurrency</h1><article class="NoteFormattedContent_note__8cHeE">
<p>Modern operating systems manage programms execution with <code>processes</code>.</p>
<p><code>Process</code> - is a basic unit of work to be implemented in a operatin system.</p>
<p>
  The OS takes a program as a set of instructions and run all it's instructions in context of some
  process. Each process has it's own <code>stack</code> and <code>heap</code>.
</p>
<p>Within one <code>process</code> program can run multiple threads.</p>
<p><code>Thread</code> - is a smallest sequence of instructions, that can be managed independently by OS scheduler.</p>
<p>Multiple thread of one process share this process's heap.</p>
<p>Multithreaded execution may have several problems:</p>
<ul>
  <li><code>Race conditions</code>, where threads are accessing data or resources in an inconsistent order</li>
  <li>
    <code>Deadlocks</code>, where two threads are waiting for each other to finish using a resource the other
    thread has, preventing both threads from continuing
  </li>
  <li>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</li>
</ul>
<p>
  Usually OS gives an public interface to create new threads. Usin it called <code>1:1</code> - one program
  thread for one OS thread. Some languages have their own implementation of threads, where it is not
  necessary one to one relationship between language and OS threads amount. Such threads called
  <code>grean threads</code>. It is <code>M:N</code> model, where <code>M</code> is amount of green threads and <code>N</code> is an amount of
  OS threads.
</p>
<p>Rust standard library provides only <code>1:1</code> model in order to have smaller runtime.</p>
<h2>Creating Threads</h2>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| {
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the spawned thread!"</span>, i);
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));
        }
    });

    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the main thread!"</span>, i);
        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));
    }
}
</code></pre>
<p><em>all started threads will be eventually stopped or when they will execute all their instructions or when main thread will be stopped</em></p>
<p>To ensure all threads finished correctly, use <code>join</code>:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| {
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the spawned thread!"</span>, i);
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));
        }
    });

    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the main thread!"</span>, i);
        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));
    }

    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
}
</code></pre>
<p>Calling <code>handle.join()</code> blocks main thread's execution until this <code>handle</code> thread will be finished.</p>
<h3>Outer Context</h3>
<p>Rust can not infer, how long thread will live, so following will not work:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Here's a vector: {:?}"</span>, v);
    });

    <span class="hljs-title function_ invoke__">drop</span>(v); <span class="hljs-comment">// oh no!</span>

    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
}
</code></pre>
<p>This can be solved my moving ownership to the thread context with <code>move</code> closure:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Here's a vector: {:?}"</span>, v);
    });

    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
}
</code></pre>
<p>
  But in this case after thread has started, we don't have access to <code>v</code> vector, because it has
  already been moved.
</p>
<h2>Synchronization</h2>
<h3>Message Passing</h3>
<p>
  <code>Message passing</code> - threads or actors communicate by sending each other messages containing data.
  As an implementation of this concept Rust uses <code>channels</code>.
</p>
<p>Channel consists of two parts:</p>
<ul>
  <li><code>transmitter</code> - is an upstream where source data is sent.</li>
  <li><code>receiver</code> - is a target location of data.</li>
</ul>
<p>Channel is closing when closing either <code>transmitter</code> or <code>receiver</code>.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::mpsc;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();

    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">val</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hi"</span>);
        tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();
    });

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">received</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Got: {}"</span>, received);
}
</code></pre>
<p>
  <code>mpsc</code> stands for multiple producer, single consumer. Channel can have multiple sending ends that
  produce values but only one receiving end that consumes those values. The <code>mpsc::channel</code> function
  returns a tuple, the first element of which is the sending end and the second element is the
  receiving end. The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in many fields for
  transmitter and receiver respectively, so we name our variables as such to indicate each end.
</p>
<p>
  We move transmitter to the new thread and send a value into it from this thread. The spawned thread
  needs to own the transmitting end of the channel to be able to send messages through the channel.
  The send method returns a <code>Result&#x3C;T, E></code> type, so if the receiving end has already been dropped
  and there’s nowhere to send a value, the send operation will return an error.
</p>
<p>Then we are able to receive sent value in the main thread with receiver instance.</p>
<p>Send moves ownership of sent variables so it is not possible to use them after that in this thread.</p>
<p>
  <code>recv</code>, short for receive, which will block the main thread’s execution and wait until a value is
  sent down the channel. Once a value is sent, recv will return it in a <code>Result&#x3C;T, E></code>. When the
  sending end of the channel closes, recv will return an error to signal that no more values will be
  coming.
</p>
<p>
  The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&#x3C;T, E></code> immediately: an <code>Ok</code>
  value holding a message if one is available and an <code>Err</code> value if there aren’t any messages this
  time. Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages:
  we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available,
  and otherwise does other work for a little while until checking again.
</p>
<h3>Multiple Producers</h3>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::mpsc;
<span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">tx1</span> = tx.<span class="hljs-title function_ invoke__">clone</span>();
    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hi"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"from"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"the"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"thread"</span>),
        ];

        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals {
            tx1.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));
        }
    });

    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"more"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"messages"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"for"</span>),
            String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"you"</span>),
        ];

        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals {
            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));
        }
    });

    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Got: {}"</span>, received);
    }
}
</code></pre>
<h2>Mutexes</h2>
<p>
  <code>Mutex</code> is an abbreviation for mutual exclusion, as in, a mutex allows only one thread to access
  some data at any given time. To access the data in a mutex, a thread must first signal that it
  wants access by asking to acquire the mutex’s lock. The lock is a data structure that is part of
  the mutex that keeps track of who currently has exclusive access to the data. Therefore, the mutex
  is described as guarding the data it holds via the locking system.
</p>
<p>There are two basic steps to use <code>mutex</code>:</p>
<ol>
  <li>Engage lock with mutex before accessing actual data</li>
  <li>Release lock from mutex to allow other threads to use it</li>
</ol>
<p>
  <strong>Mutex</strong> - is a smart pointer allowing to access inner data concurrently. To use inner value
  we have to call <code>lock</code> method on it. It will block the thread and return a <code>LockResult</code>. If the
  value is locked by another thread it will wait for release. If another thread, which locked
  resource before current <code>lock</code> call paniced, <code>LockResult</code> will return error. Success case is
  <code>MutexGuard</code>, which points to actual data. It implements <code>Deref</code> and <code>Drop</code> traits, so it will
  automatically release the locked value after <code>MutexGuard</code> will go out of scope.
</p>
<p>Let's see, how to use mutex in Rust on example:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::Mutex;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);

    {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        *num = <span class="hljs-number">6</span>;
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"m = {:?}"</span>, m);
}
</code></pre>
<p><strong>Sharing mutexes between threads:</strong></p>
<p>
  <code>Mutex&#x3C;T></code> can not be easily shared between threads because of ownership rules ensuring, that
  there is only a single owner of the variable may exist at one moment of time. So we have to use
  wrapping to another smart pointer. We may try to use <code>Rc&#x3C;T></code> smart pointer, but although it
  can solve the problem partially, it is not intended to use in multithreaded context. But there is
  a similar concpet - <code>std::sync::atomic::Arc&#x3C;T></code>, which does the same, <code>Rc&#x3C;T></code> can, but with
  guarantees for thread safety.
</p>
<p>
  The reason, why functionality of <code>Arc&#x3C;T></code> does not embedded into regular <code>Rc&#x3C;T></code> is little
  performance downgrade as a price for thread safety. So if we don't require synchronization,
  we normally don't need this guarantees.
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::{Arc, Mutex};
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];

    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&#x26;counter);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

            *num += <span class="hljs-number">1</span>;
        });
        handles.<span class="hljs-title function_ invoke__">push</span>(handle);
    }

    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles {
        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Result: {}"</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());
}
</code></pre>
<h2>Send</h2>
<p>
  To be able to send objects and their ownership between threads, these objects have to implement
  <code>Sync</code> trait. By default almost all Rust objects implements it. But there are some exceptions, like
  <code>Rc&#x3C;T></code>, which is not thread safe.
</p>
<h2>Sync</h2>
<p><code>Sync</code> is a trait, which shows that type, implementing <code>Send</code> may be safely referenced by many threads.</p>
<p>
  Complex types, which consist of other <code>Send</code> + <code>Sync</code> compatible objects are automatically also
  implement <code>Send+Sync</code>.
</p>
<h2>References</h2>
<ul>
  <li><a href="https://doc.rust-lang.org/stable/book/ch16-01-threads.html">Using Threads to Run Code Simultaneously</a></li>
  <li><a href="https://www.tutorialspoint.com/operating_system/os_processes.html">Operating System - Processes</a></li>
  <li><a href="https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html">Using Message Passing to Transfer Data Between Threads</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["rust","concurrency"],"note":{"title":"Rust Concurrency","date":"2022-03-05","content":"\n\u003cp\u003eModern operating systems manage programms execution with \u003ccode\u003eprocesses\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eProcess\u003c/code\u003e - is a basic unit of work to be implemented in a operatin system.\u003c/p\u003e\n\u003cp\u003e\n  The OS takes a program as a set of instructions and run all it's instructions in context of some\n  process. Each process has it's own \u003ccode\u003estack\u003c/code\u003e and \u003ccode\u003eheap\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003eWithin one \u003ccode\u003eprocess\u003c/code\u003e program can run multiple threads.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eThread\u003c/code\u003e - is a smallest sequence of instructions, that can be managed independently by OS scheduler.\u003c/p\u003e\n\u003cp\u003eMultiple thread of one process share this process's heap.\u003c/p\u003e\n\u003cp\u003eMultithreaded execution may have several problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eRace conditions\u003c/code\u003e, where threads are accessing data or resources in an inconsistent order\u003c/li\u003e\n  \u003cli\u003e\n    \u003ccode\u003eDeadlocks\u003c/code\u003e, where two threads are waiting for each other to finish using a resource the other\n    thread has, preventing both threads from continuing\n  \u003c/li\u003e\n  \u003cli\u003eBugs that happen only in certain situations and are hard to reproduce and fix reliably\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  Usually OS gives an public interface to create new threads. Usin it called \u003ccode\u003e1:1\u003c/code\u003e - one program\n  thread for one OS thread. Some languages have their own implementation of threads, where it is not\n  necessary one to one relationship between language and OS threads amount. Such threads called\n  \u003ccode\u003egrean threads\u003c/code\u003e. It is \u003ccode\u003eM:N\u003c/code\u003e model, where \u003ccode\u003eM\u003c/code\u003e is amount of green threads and \u003ccode\u003eN\u003c/code\u003e is an amount of\n  OS threads.\n\u003c/p\u003e\n\u003cp\u003eRust standard library provides only \u003ccode\u003e1:1\u003c/code\u003e model in order to have smaller runtime.\u003c/p\u003e\n\u003ch2\u003eCreating Threads\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::time::Duration;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(|| {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi number {} from the spawned thread!\"\u003c/span\u003e, i);\n            thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_millis\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n        }\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi number {} from the main thread!\"\u003c/span\u003e, i);\n        thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_millis\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eall started threads will be eventually stopped or when they will execute all their instructions or when main thread will be stopped\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eTo ensure all threads finished correctly, use \u003ccode\u003ejoin\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::time::Duration;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehandle\u003c/span\u003e = thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(|| {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi number {} from the spawned thread!\"\u003c/span\u003e, i);\n            thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_millis\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n        }\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ei\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi number {} from the main thread!\"\u003c/span\u003e, i);\n        thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_millis\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n    }\n\n    handle.\u003cspan class=\"hljs-title function_ invoke__\"\u003ejoin\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCalling \u003ccode\u003ehandle.join()\u003c/code\u003e blocks main thread's execution until this \u003ccode\u003ehandle\u003c/code\u003e thread will be finished.\u003c/p\u003e\n\u003ch3\u003eOuter Context\u003c/h3\u003e\n\u003cp\u003eRust can not infer, how long thread will live, so following will not work:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ev\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehandle\u003c/span\u003e = thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(|| {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Here's a vector: {:?}\"\u003c/span\u003e, v);\n    });\n\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003edrop\u003c/span\u003e(v); \u003cspan class=\"hljs-comment\"\u003e// oh no!\u003c/span\u003e\n\n    handle.\u003cspan class=\"hljs-title function_ invoke__\"\u003ejoin\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis can be solved my moving ownership to the thread context with \u003ccode\u003emove\u003c/code\u003e closure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ev\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehandle\u003c/span\u003e = thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Here's a vector: {:?}\"\u003c/span\u003e, v);\n    });\n\n    handle.\u003cspan class=\"hljs-title function_ invoke__\"\u003ejoin\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  But in this case after thread has started, we don't have access to \u003ccode\u003ev\u003c/code\u003e vector, because it has\n  already been moved.\n\u003c/p\u003e\n\u003ch2\u003eSynchronization\u003c/h2\u003e\n\u003ch3\u003eMessage Passing\u003c/h3\u003e\n\u003cp\u003e\n  \u003ccode\u003eMessage passing\u003c/code\u003e - threads or actors communicate by sending each other messages containing data.\n  As an implementation of this concept Rust uses \u003ccode\u003echannels\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003eChannel consists of two parts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003etransmitter\u003c/code\u003e - is an upstream where source data is sent.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ereceiver\u003c/code\u003e - is a target location of data.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChannel is closing when closing either \u003ccode\u003etransmitter\u003c/code\u003e or \u003ccode\u003ereceiver\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::sync::mpsc;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (tx, rx) = mpsc::\u003cspan class=\"hljs-title function_ invoke__\"\u003echannel\u003c/span\u003e();\n\n    thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eval\u003c/span\u003e = String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi\"\u003c/span\u003e);\n        tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(val).\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ereceived\u003c/span\u003e = rx.\u003cspan class=\"hljs-title function_ invoke__\"\u003erecv\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Got: {}\"\u003c/span\u003e, received);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  \u003ccode\u003empsc\u003c/code\u003e stands for multiple producer, single consumer. Channel can have multiple sending ends that\n  produce values but only one receiving end that consumes those values. The \u003ccode\u003empsc::channel\u003c/code\u003e function\n  returns a tuple, the first element of which is the sending end and the second element is the\n  receiving end. The abbreviations \u003ccode\u003etx\u003c/code\u003e and \u003ccode\u003erx\u003c/code\u003e are traditionally used in many fields for\n  transmitter and receiver respectively, so we name our variables as such to indicate each end.\n\u003c/p\u003e\n\u003cp\u003e\n  We move transmitter to the new thread and send a value into it from this thread. The spawned thread\n  needs to own the transmitting end of the channel to be able to send messages through the channel.\n  The send method returns a \u003ccode\u003eResult\u0026#x3C;T, E\u003e\u003c/code\u003e type, so if the receiving end has already been dropped\n  and there’s nowhere to send a value, the send operation will return an error.\n\u003c/p\u003e\n\u003cp\u003eThen we are able to receive sent value in the main thread with receiver instance.\u003c/p\u003e\n\u003cp\u003eSend moves ownership of sent variables so it is not possible to use them after that in this thread.\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003erecv\u003c/code\u003e, short for receive, which will block the main thread’s execution and wait until a value is\n  sent down the channel. Once a value is sent, recv will return it in a \u003ccode\u003eResult\u0026#x3C;T, E\u003e\u003c/code\u003e. When the\n  sending end of the channel closes, recv will return an error to signal that no more values will be\n  coming.\n\u003c/p\u003e\n\u003cp\u003e\n  The \u003ccode\u003etry_recv\u003c/code\u003e method doesn’t block, but will instead return a \u003ccode\u003eResult\u0026#x3C;T, E\u003e\u003c/code\u003e immediately: an \u003ccode\u003eOk\u003c/code\u003e\n  value holding a message if one is available and an \u003ccode\u003eErr\u003c/code\u003e value if there aren’t any messages this\n  time. Using \u003ccode\u003etry_recv\u003c/code\u003e is useful if this thread has other work to do while waiting for messages:\n  we could write a loop that calls \u003ccode\u003etry_recv\u003c/code\u003e every so often, handles a message if one is available,\n  and otherwise does other work for a little while until checking again.\n\u003c/p\u003e\n\u003ch3\u003eMultiple Producers\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::sync::mpsc;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::time::Duration;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (tx, rx) = mpsc::\u003cspan class=\"hljs-title function_ invoke__\"\u003echannel\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003etx1\u003c/span\u003e = tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e();\n    thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003evals\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hi\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"from\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"the\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"thread\"\u003c/span\u003e),\n        ];\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e vals {\n            tx1.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(val).\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n            thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_secs\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n        }\n    });\n\n    thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003evals\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"more\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"for\"\u003c/span\u003e),\n            String::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"you\"\u003c/span\u003e),\n        ];\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e vals {\n            tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003esend\u003c/span\u003e(val).\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n            thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003esleep\u003c/span\u003e(Duration::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom_secs\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n        }\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ereceived\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e rx {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Got: {}\"\u003c/span\u003e, received);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMutexes\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003eMutex\u003c/code\u003e is an abbreviation for mutual exclusion, as in, a mutex allows only one thread to access\n  some data at any given time. To access the data in a mutex, a thread must first signal that it\n  wants access by asking to acquire the mutex’s lock. The lock is a data structure that is part of\n  the mutex that keeps track of who currently has exclusive access to the data. Therefore, the mutex\n  is described as guarding the data it holds via the locking system.\n\u003c/p\u003e\n\u003cp\u003eThere are two basic steps to use \u003ccode\u003emutex\u003c/code\u003e:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eEngage lock with mutex before accessing actual data\u003c/li\u003e\n  \u003cli\u003eRelease lock from mutex to allow other threads to use it\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n  \u003cstrong\u003eMutex\u003c/strong\u003e - is a smart pointer allowing to access inner data concurrently. To use inner value\n  we have to call \u003ccode\u003elock\u003c/code\u003e method on it. It will block the thread and return a \u003ccode\u003eLockResult\u003c/code\u003e. If the\n  value is locked by another thread it will wait for release. If another thread, which locked\n  resource before current \u003ccode\u003elock\u003c/code\u003e call paniced, \u003ccode\u003eLockResult\u003c/code\u003e will return error. Success case is\n  \u003ccode\u003eMutexGuard\u003c/code\u003e, which points to actual data. It implements \u003ccode\u003eDeref\u003c/code\u003e and \u003ccode\u003eDrop\u003c/code\u003e traits, so it will\n  automatically release the locked value after \u003ccode\u003eMutexGuard\u003c/code\u003e will go out of scope.\n\u003c/p\u003e\n\u003cp\u003eLet's see, how to use mutex in Rust on example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::sync::Mutex;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003em\u003c/span\u003e = Mutex::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n\n    {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003enum\u003c/span\u003e = m.\u003cspan class=\"hljs-title function_ invoke__\"\u003elock\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n        *num = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"m = {:?}\"\u003c/span\u003e, m);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSharing mutexes between threads:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003eMutex\u0026#x3C;T\u003e\u003c/code\u003e can not be easily shared between threads because of ownership rules ensuring, that\n  there is only a single owner of the variable may exist at one moment of time. So we have to use\n  wrapping to another smart pointer. We may try to use \u003ccode\u003eRc\u0026#x3C;T\u003e\u003c/code\u003e smart pointer, but although it\n  can solve the problem partially, it is not intended to use in multithreaded context. But there is\n  a similar concpet - \u003ccode\u003estd::sync::atomic::Arc\u0026#x3C;T\u003e\u003c/code\u003e, which does the same, \u003ccode\u003eRc\u0026#x3C;T\u003e\u003c/code\u003e can, but with\n  guarantees for thread safety.\n\u003c/p\u003e\n\u003cp\u003e\n  The reason, why functionality of \u003ccode\u003eArc\u0026#x3C;T\u003e\u003c/code\u003e does not embedded into regular \u003ccode\u003eRc\u0026#x3C;T\u003e\u003c/code\u003e is little\n  performance downgrade as a price for thread safety. So if we don't require synchronization,\n  we normally don't need this guarantees.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::sync::{Arc, Mutex};\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e std::thread;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ecounter\u003c/span\u003e = Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(Mutex::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e));\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehandles\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evec!\u003c/span\u003e[];\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ecounter\u003c/span\u003e = Arc::\u003cspan class=\"hljs-title function_ invoke__\"\u003eclone\u003c/span\u003e(\u0026#x26;counter);\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ehandle\u003c/span\u003e = thread::\u003cspan class=\"hljs-title function_ invoke__\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003enum\u003c/span\u003e = counter.\u003cspan class=\"hljs-title function_ invoke__\"\u003elock\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n\n            *num += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n        });\n        handles.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush\u003c/span\u003e(handle);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehandle\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e handles {\n        handle.\u003cspan class=\"hljs-title function_ invoke__\"\u003ejoin\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    }\n\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Result: {}\"\u003c/span\u003e, *counter.\u003cspan class=\"hljs-title function_ invoke__\"\u003elock\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSend\u003c/h2\u003e\n\u003cp\u003e\n  To be able to send objects and their ownership between threads, these objects have to implement\n  \u003ccode\u003eSync\u003c/code\u003e trait. By default almost all Rust objects implements it. But there are some exceptions, like\n  \u003ccode\u003eRc\u0026#x3C;T\u003e\u003c/code\u003e, which is not thread safe.\n\u003c/p\u003e\n\u003ch2\u003eSync\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eSync\u003c/code\u003e is a trait, which shows that type, implementing \u003ccode\u003eSend\u003c/code\u003e may be safely referenced by many threads.\u003c/p\u003e\n\u003cp\u003e\n  Complex types, which consist of other \u003ccode\u003eSend\u003c/code\u003e + \u003ccode\u003eSync\u003c/code\u003e compatible objects are automatically also\n  implement \u003ccode\u003eSend+Sync\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://doc.rust-lang.org/stable/book/ch16-01-threads.html\"\u003eUsing Threads to Run Code Simultaneously\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.tutorialspoint.com/operating_system/os_processes.html\"\u003eOperating System - Processes\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html\"\u003eUsing Message Passing to Transfer Data Between Threads\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["rust","concurrency"]},"buildId":"TLVs-fHNJx4QzHIHhPfMV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>