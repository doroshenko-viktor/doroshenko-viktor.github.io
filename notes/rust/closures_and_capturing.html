<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Closures And Capturing</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_buildManifest.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_ssgManifest.js" defer=""></script><script src="/_next/static/rEbIxoA2O-xiW5DUZwlG8/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Closures And Capturing</h1><article class="NoteFormattedContent_note__8cHeE">
<p><code>Closure</code> in Rust is a function which is able to capture vairable from context, which is global to it.</p>
<p>For example:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">const</span> x: <span class="hljs-type">u8</span> = <span class="hljs-number">10u8</span>;
<span class="hljs-keyword">const</span> closure: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">u8</span> = |y: <span class="hljs-type">u8</span>| <span class="hljs-punctuation">-></span> <span class="hljs-type">u8</span> x * y;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">func</span>() <span class="hljs-punctuation">-></span> <span class="hljs-type">u8</span> {
    <span class="hljs-title function_ invoke__">closure</span>(<span class="hljs-number">5u8</span>)
}
</code></pre>
<p>It is allowed in Rust to not put type annotations in closure definition. This way types will be infered from the context.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">closure</span> = |y| x * y;
</code></pre>
<p>
  By default Rust compiler takes least possible ownership on enclosed variables. To force closure to take ownership on
  enclosed scope you can use <code>move</code> keyword:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">with_moving_ownership</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5u8</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">closure</span> = <span class="hljs-keyword">move</span> || {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x)
    }

    <span class="hljs-comment">// here x is not available</span>
}
</code></pre>
<h2>Passing Closure As A Parameter</h2>
<p>
  But when passing a reference to the closure, definition of it's signature is mandatory. To desribe closure there are exist
  several traits:
</p>
<ul>
  <li><code>Fn</code> - this means, that captured values will be reference with <code>&#x26;</code></li>
  <li><code>FnOnce</code> - closure takes full ownership on the captured values</li>
  <li><code>FnMut</code> - closure has mutable reference on the captures values with <code>&#x26;mut</code></li>
</ul>
<p>
  But these traits define a maximum restriction possible for access to closed scope. But it does not mean that this borrowing
  will actually happen. If compiler will see that it can use less restrictive borrowing rule it will use it.
</p>
<p>Any regular function, which satisfies to the required function trait may be passed as a parameter instead of closure.</p>
<h2>Returning A Closure From Function</h2>
<p>
  It is possible to return closure from function. But it is associated with additional restrictions. Returned closure must
  own all it's enclosed variables. To do this, use <code>move</code> keyword. Also we have to use <code>impl</code> keyword for returned closure type, e.g:
</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_sum</span>() <span class="hljs-punctuation">-></span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Fn</span>(<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">u8</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x1</span> = <span class="hljs-number">5u8</span>;

    <span class="hljs-keyword">move</span> |y| y + x1
}
</code></pre>
<p>Or return pointer to function:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_sum_box</span>() <span class="hljs-punctuation">-></span> <span class="hljs-type">Box</span>&#x3C;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">u8</span>> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x1</span> = <span class="hljs-number">5u8</span>;

    Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">move</span> |y| y * x1)
}
</code></pre>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["rust","closures_and_capturing"],"note":{"title":"Closures And Capturing","date":"2022-10-17","content":"\n\u003cp\u003e\u003ccode\u003eClosure\u003c/code\u003e in Rust is a function which is able to capture vairable from context, which is global to it.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e x: \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e10u8\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e closure: \u003cspan class=\"hljs-title function_ invoke__\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e = |y: \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e| \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e x * y;\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eclosure\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5u8\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is allowed in Rust to not put type annotations in closure definition. This way types will be infered from the context.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eclosure\u003c/span\u003e = |y| x * y;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  By default Rust compiler takes least possible ownership on enclosed variables. To force closure to take ownership on\n  enclosed scope you can use \u003ccode\u003emove\u003c/code\u003e keyword:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewith_moving_ownership\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5u8\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eclosure\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e || {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, x)\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// here x is not available\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ePassing Closure As A Parameter\u003c/h2\u003e\n\u003cp\u003e\n  But when passing a reference to the closure, definition of it's signature is mandatory. To desribe closure there are exist\n  several traits:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eFn\u003c/code\u003e - this means, that captured values will be reference with \u003ccode\u003e\u0026#x26;\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eFnOnce\u003c/code\u003e - closure takes full ownership on the captured values\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eFnMut\u003c/code\u003e - closure has mutable reference on the captures values with \u003ccode\u003e\u0026#x26;mut\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  But these traits define a maximum restriction possible for access to closed scope. But it does not mean that this borrowing\n  will actually happen. If compiler will see that it can use less restrictive borrowing rule it will use it.\n\u003c/p\u003e\n\u003cp\u003eAny regular function, which satisfies to the required function trait may be passed as a parameter instead of closure.\u003c/p\u003e\n\u003ch2\u003eReturning A Closure From Function\u003c/h2\u003e\n\u003cp\u003e\n  It is possible to return closure from function. But it is associated with additional restrictions. Returned closure must\n  own all it's enclosed variables. To do this, use \u003ccode\u003emove\u003c/code\u003e keyword. Also we have to use \u003ccode\u003eimpl\u003c/code\u003e keyword for returned closure type, e.g:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate_sum\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFn\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex1\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5u8\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e |y| y + x1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr return pointer to function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate_sum_box\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eBox\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003edyn\u003c/span\u003e \u003cspan class=\"hljs-title function_ invoke__\"\u003eFn\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003ex1\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e5u8\u003c/span\u003e;\n\n    Box::\u003cspan class=\"hljs-title function_ invoke__\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emove\u003c/span\u003e |y| y * x1)\n}\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["rust","closures_and_capturing"]},"buildId":"rEbIxoA2O-xiW5DUZwlG8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>