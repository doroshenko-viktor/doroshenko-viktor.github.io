<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Rust Useful Traits</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_buildManifest.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_ssgManifest.js" defer=""></script><script src="/_next/static/IjqNhIRqaAJaH2DY5dkbz/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Rust Useful Traits</h1><article class="NoteFormattedContent_note__8cHeE">
<h2>Comparison</h2>
<h3>std::cmp::PartialEq</h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#">Full Doc</a></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">PartialEq</span>&#x3C;Rhs = <span class="hljs-keyword">Self</span>>
<span class="hljs-keyword">where</span> Rhs: ?<span class="hljs-built_in">Sized</span>,
{
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ne</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { ... }
}
</code></pre>
<p>Trait for equality comparisons which are partial equivalence relations.</p>
<p><code>x.eq(y)</code> can also be written <code>x == y</code>, and <code>x.ne(y)</code> can be written <code>x != y</code>.</p>
<p>Implementations must ensure that <code>eq</code> and <code>ne</code> are consistent with each other.</p>
<p>This trait can be used with <code>#[derive]</code>. When derived on <code>structs</code>, two instances are equal if all fields are equal, and not equal if any fields are not equal. When derived on <code>enums</code>, each variant is equal to itself and not equal to the other variants.</p>
<h3>std::cmp::PartialOrd</h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">Full Doc</a></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">PartialOrd</span>&#x3C;Rhs = <span class="hljs-keyword">Self</span>>: <span class="hljs-built_in">PartialEq</span>&#x3C;Rhs>
<span class="hljs-keyword">where</span> Rhs: ?<span class="hljs-built_in">Sized</span>,
{
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;Ordering>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lt</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { ... }
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">le</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { ... }
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">gt</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { ... }
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ge</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;Rhs) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { ... }
}
</code></pre>
<p>Trait for values that can be compared for a sort-order.</p>
<p>The <code>lt</code>, <code>le</code>, <code>gt</code>, and ge methods of this trait can be called using the <code>&#x3C;</code>, <code>&#x3C;=</code>, <code>></code>, and <code>>=</code> operators, respectively.</p>
<p>The methods of this trait must be consistent with each other and with those of <code>PartialEq</code> in the following sense:</p>
<p>
  <code>a == b</code> if and only if <code>partial_cmp(a, b) == Some(Equal)</code>.
  <code>a &#x3C; b</code> if and only if <code>partial_cmp(a, b) == Some(Less)</code> (ensured by the default implementation).
  <code>a > b</code> if and only if partial_cmp(a, b) == Some(Greater) (ensured by the default implementation).
  <code>a &#x3C;= b</code> if and only if <code>a &#x3C; b || a == b</code> (ensured by the default implementation).
  <code>a >= b </code>if and only if <code>a > b || a == b </code>(ensured by the default implementation).
  <code>a != b</code> if and only if <code>!(a == b)</code> (already part of PartialEq).
</p>
<h2>Lifecycle</h2>
<h3>std::ops::Drop</h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Full Doc</a></p>
<p>Represents deconstructor for object, which will be called, when object is deleting.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasDrop</span>;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HasDrop</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Dropping HasDrop!"</span>);
    }
}
</code></pre>
<p>e.g. <code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> implement the <code>Drop</code> trait to free resources.</p>
<h3>std::ops::Deref</h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Full Doc</a></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> &#x26;<span class="hljs-keyword">Self</span>::Target;
}
</code></pre>
<p>Used for immutable dereferencing operations, like <code>*v</code>. <code>Deref</code> also used implicitly by the compiler in many circumstances. This mechanism is called <code>Deref coercion</code>. In mutable contexts, <code>DerefMut</code> is used.</p>
<p><code>Deref</code> should only be implemented for smart pointers to avoid confusion. This trait should never fail. Failure during dereferencing can be extremely confusing when <code>Deref</code> is invoked implicitly.</p>
<h2>Operators</h2>
<h3>std::ops::Index</h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">Doc</a></p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Index</span>&#x3C;Idx> 
<span class="hljs-keyword">where</span>
    Idx: ?<span class="hljs-built_in">Sized</span>, 
{
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>: ?<span class="hljs-built_in">Sized</span>;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>(&#x26;<span class="hljs-keyword">self</span>, index: Idx) <span class="hljs-punctuation">-></span> &#x26;<span class="hljs-keyword">Self</span>::Output;
}
</code></pre>
<p>Used for indexing operations <code>(</code>container[index]<code>)</code> in immutable contexts.</p>
<p><code>container[index]</code> is actually syntactic sugar for <code>*container.index(index)</code>, but only when used as an immutable value. If a mutable value is requested, <code>IndexMut</code> is used instead. This allows nice things such as <code>let value = v[index]</code> if the type of value implements <code>Copy</code>.</p>
<h2>Async</h2>
<h3>std::future::Future</h3>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html">Full Doc</a></p>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["rust","useful-traits"],"note":{"title":"Rust Useful Traits","date":"2022-04-04","content":"\n\u003ch2\u003eComparison\u003c/h2\u003e\n\u003ch3\u003estd::cmp::PartialEq\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#\"\u003eFull Doc\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePartialEq\u003c/span\u003e\u0026#x3C;Rhs = \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e\u003e\n\u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e Rhs: ?\u003cspan class=\"hljs-built_in\"\u003eSized\u003c/span\u003e,\n{\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eeq\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ene\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTrait for equality comparisons which are partial equivalence relations.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ex.eq(y)\u003c/code\u003e can also be written \u003ccode\u003ex == y\u003c/code\u003e, and \u003ccode\u003ex.ne(y)\u003c/code\u003e can be written \u003ccode\u003ex != y\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eImplementations must ensure that \u003ccode\u003eeq\u003c/code\u003e and \u003ccode\u003ene\u003c/code\u003e are consistent with each other.\u003c/p\u003e\n\u003cp\u003eThis trait can be used with \u003ccode\u003e#[derive]\u003c/code\u003e. When derived on \u003ccode\u003estructs\u003c/code\u003e, two instances are equal if all fields are equal, and not equal if any fields are not equal. When derived on \u003ccode\u003eenums\u003c/code\u003e, each variant is equal to itself and not equal to the other variants.\u003c/p\u003e\n\u003ch3\u003estd::cmp::PartialOrd\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\"\u003eFull Doc\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePartialOrd\u003c/span\u003e\u0026#x3C;Rhs = \u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e\u003e: \u003cspan class=\"hljs-built_in\"\u003ePartialEq\u003c/span\u003e\u0026#x3C;Rhs\u003e\n\u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e Rhs: ?\u003cspan class=\"hljs-built_in\"\u003eSized\u003c/span\u003e,\n{\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epartial_cmp\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;Ordering\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e { ... }\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ele\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e { ... }\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egt\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e { ... }\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ege\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;Rhs) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTrait for values that can be compared for a sort-order.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003elt\u003c/code\u003e, \u003ccode\u003ele\u003c/code\u003e, \u003ccode\u003egt\u003c/code\u003e, and ge methods of this trait can be called using the \u003ccode\u003e\u0026#x3C;\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;=\u003c/code\u003e, \u003ccode\u003e\u003e\u003c/code\u003e, and \u003ccode\u003e\u003e=\u003c/code\u003e operators, respectively.\u003c/p\u003e\n\u003cp\u003eThe methods of this trait must be consistent with each other and with those of \u003ccode\u003ePartialEq\u003c/code\u003e in the following sense:\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003ea == b\u003c/code\u003e if and only if \u003ccode\u003epartial_cmp(a, b) == Some(Equal)\u003c/code\u003e.\n  \u003ccode\u003ea \u0026#x3C; b\u003c/code\u003e if and only if \u003ccode\u003epartial_cmp(a, b) == Some(Less)\u003c/code\u003e (ensured by the default implementation).\n  \u003ccode\u003ea \u003e b\u003c/code\u003e if and only if partial_cmp(a, b) == Some(Greater) (ensured by the default implementation).\n  \u003ccode\u003ea \u0026#x3C;= b\u003c/code\u003e if and only if \u003ccode\u003ea \u0026#x3C; b || a == b\u003c/code\u003e (ensured by the default implementation).\n  \u003ccode\u003ea \u003e= b \u003c/code\u003eif and only if \u003ccode\u003ea \u003e b || a == b \u003c/code\u003e(ensured by the default implementation).\n  \u003ccode\u003ea != b\u003c/code\u003e if and only if \u003ccode\u003e!(a == b)\u003c/code\u003e (already part of PartialEq).\n\u003c/p\u003e\n\u003ch2\u003eLifecycle\u003c/h2\u003e\n\u003ch3\u003estd::ops::Drop\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/ops/trait.Drop.html\"\u003eFull Doc\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRepresents deconstructor for object, which will be called, when object is deleting.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHasDrop\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrop\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHasDrop\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrop\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) {\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Dropping HasDrop!\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ee.g. \u003ccode\u003eBox\u003c/code\u003e, \u003ccode\u003eVec\u003c/code\u003e, \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eFile\u003c/code\u003e, and \u003ccode\u003eProcess\u003c/code\u003e implement the \u003ccode\u003eDrop\u003c/code\u003e trait to free resources.\u003c/p\u003e\n\u003ch3\u003estd::ops::Deref\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\"\u003eFull Doc\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDeref\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTarget\u003c/span\u003e: ?\u003cspan class=\"hljs-built_in\"\u003eSized\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ederef\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e::Target;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsed for immutable dereferencing operations, like \u003ccode\u003e*v\u003c/code\u003e. \u003ccode\u003eDeref\u003c/code\u003e also used implicitly by the compiler in many circumstances. This mechanism is called \u003ccode\u003eDeref coercion\u003c/code\u003e. In mutable contexts, \u003ccode\u003eDerefMut\u003c/code\u003e is used.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDeref\u003c/code\u003e should only be implemented for smart pointers to avoid confusion. This trait should never fail. Failure during dereferencing can be extremely confusing when \u003ccode\u003eDeref\u003c/code\u003e is invoked implicitly.\u003c/p\u003e\n\u003ch2\u003eOperators\u003c/h2\u003e\n\u003ch3\u003estd::ops::Index\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/ops/trait.Index.html\"\u003eDoc\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIndex\u003c/span\u003e\u0026#x3C;Idx\u003e \n\u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e\n    Idx: ?\u003cspan class=\"hljs-built_in\"\u003eSized\u003c/span\u003e, \n{\n    \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: ?\u003cspan class=\"hljs-built_in\"\u003eSized\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eindex\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, index: Idx) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e::Output;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsed for indexing operations \u003ccode\u003e(\u003c/code\u003econtainer[index]\u003ccode\u003e)\u003c/code\u003e in immutable contexts.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtainer[index]\u003c/code\u003e is actually syntactic sugar for \u003ccode\u003e*container.index(index)\u003c/code\u003e, but only when used as an immutable value. If a mutable value is requested, \u003ccode\u003eIndexMut\u003c/code\u003e is used instead. This allows nice things such as \u003ccode\u003elet value = v[index]\u003c/code\u003e if the type of value implements \u003ccode\u003eCopy\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eAsync\u003c/h2\u003e\n\u003ch3\u003estd::future::Future\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/std/future/trait.Future.html\"\u003eFull Doc\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["rust","useful-traits"]},"buildId":"IjqNhIRqaAJaH2DY5dkbz","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>