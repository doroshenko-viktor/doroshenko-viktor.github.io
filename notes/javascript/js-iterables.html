<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>JS - Iterables And Collections</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/6V8_yxN3djhrhbRemYkax/_buildManifest.js" defer=""></script><script src="/_next/static/6V8_yxN3djhrhbRemYkax/_ssgManifest.js" defer=""></script><script src="/_next/static/6V8_yxN3djhrhbRemYkax/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">JS - Iterables And Collections</h1><article class="NoteFormattedContent_note__8cHeE">
<h2>Iterables</h2>
<p>
  In <code>JS</code> iterables are objects, which implement <code>iterable</code> protocol and have <code>@@iterator</code> method.
  Those are arrays, linked lists, maps, sets, strings and so on.
</p>
<p>
  There are also <code>array-like objects</code> - objects, that have a length and possibility to acces it's
  elements by index.
</p>
<h2>Array</h2>
<p>To create an array in <code>JS</code> there are many possible ways:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-string">'elem'</span>];
<span class="hljs-keyword">const</span> a2 = <span class="hljs-title class_">Array</span>(<span class="hljs-string">'elem'</span>);
<span class="hljs-keyword">const</span> a3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">'elem'</span>);
<span class="hljs-keyword">const</span> a4 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">'elem'</span>);
<span class="hljs-keyword">const</span> a5 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'elem'</span>);
</code></pre>
<p><em>Note: <code>new Array(5)</code> or <code>Array(5)</code> will create new empty array with given length of 5</em></p>
<p>
  <code>Array.from(iterable)</code> - this method is meant to convert an array-like object or iterable to an
  actual array.
</p>
<p>e.g.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'string'</span>);
<span class="hljs-comment">// will contain ['s', 't','r', 'i', 'n', 'g'];</span>
</code></pre>
<h3>Looping Over Array</h3>
<p>To loop over an iterable object we can use <code>for .. of ..</code> loop:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> data <span class="hljs-keyword">of</span> iterable) {}
</code></pre>
<h3>Array Methods</h3>
<p><strong>push:</strong></p>
<p>To add an element to the end of the collection use <code>push</code> method:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
elems.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);
<span class="hljs-comment">// will contain [1,2,3,4]</span>
</code></pre>
<p><strong>unshift:</strong></p>
<p>To add an element to the beginning of the collection use <code>unshift</code> method:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
elems.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elems);
<span class="hljs-comment">// will contain [0,1,2,3]</span>
</code></pre>
<p><strong>pop:</strong></p>
<p><code>pop</code> method removes last element of a collection and returns it:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> lastElem = elems.<span class="hljs-title function_">pop</span>();
</code></pre>
<p><strong>shift:</strong></p>
<p>Method <code>shift</code> removes one element from the beginning of a collection:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> firstElem = elems.<span class="hljs-title function_">shift</span>();
</code></pre>
<p><strong>splice:</strong></p>
<p>
  Method <code>splice</code> allows to remove arbitrary number of elements in the given array and replace them
  with any number of new elements. It is an array method an can't be called on other iterables.
</p>
<p><code>arr.splice(&#x3C;start position>, &#x3C;amount of removed elements>, ...&#x3C;collection of elements to insert>)</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
elems.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);
<span class="hljs-comment">// result elems => [1, 5, 6]</span>
</code></pre>
<p>It is also possible to remove elements counting from the tail. To do this use less than 0 index:</p>
<pre><code class="hljs language-js">elems.<span class="hljs-title function_">splice</span>(-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>);
<span class="hljs-comment">// result elems => [1, 7, 6]</span>
</code></pre>
<p><strong>slice:</strong></p>
<p><code>slice</code> method allows to create a copy of some part of the array:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> elemsCopy = elems1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
<span class="hljs-comment">// elemsCopy: [3, 4]</span>
</code></pre>
<p>It is also possible to use negative indexes to count from the tail of the collection.</p>
<p>Not specifying range will copy the entire array:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> fullCopy = elems1.<span class="hljs-title function_">slice</span>();
</code></pre>
<p><strong>concat:</strong></p>
<p>
  <code>concat</code> method accepts another collection and return as a result new array, where current and
  given array are concatenated together. It does not change original array.
</p>
<p><strong>indexOf:</strong></p>
<p>
  <code>indexOf</code> allows to find index of specified element in the collection. Second argument allows to
  define starting position to search. If specified, any previous hits will not be counted.
  If nothing found result will be <code>-1</code>.
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elemsToSearch = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> i = elemsToSearch.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// `i` will be 5</span>
</code></pre>
<p><strong>includes:</strong></p>
<p>Allows to check wheather given element exists in collection:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elems = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> exists3 = elems.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><em>Important to notice, that it will work with value types, because equality of reference types
words differently</em></p>
<p><strong>lastIndexOf:</strong></p>
<p>
  <code>lastIndexOf</code> has the same functionality as <code>indexOf</code>. The only difference - it searches starting
  from the end of the collection towards it's beginning.
</p>
<p><strong>find:</strong></p>
<p><code>find</code> allows to search for required element in the specified array by given predicate:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> complElemsToSearch = [{ <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> }, { <span class="hljs-attr">key</span>: <span class="hljs-number">2</span> }, { <span class="hljs-attr">key</span>: <span class="hljs-number">3</span> }];
<span class="hljs-keyword">const</span> foundElem = complElemsToSearch
  .<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">val, ind, arr</span>) =></span> val.<span class="hljs-property">key</span> === <span class="hljs-number">2</span>);
</code></pre>
<p>
  Where <code>val</code> is a reference to the current iteration value, <code>ind</code> - index of current iteration and
  <code>arr</code> is a reference to the whole array.
</p>
<p>
  It returns reference to the found object, but no it's index.
  To search for index use <code>findIndex</code> method with the same signature.
</p>
<p><strong>forEach:</strong></p>
<p>
  This method allows to iterate over every item in the array and perform some action, specified with
  provided function.
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elements = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
elements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, ind, arr</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`current value is <span class="hljs-subst">${val}</span>`</span>);
})
</code></pre>
<p><strong>map:</strong></p>
<p>
  If there is a need to perform some action on every element of a collection and store results in a
  new collection, it can't acheived with <code>map</code> method:
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elements = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> resultElements = elements
  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val, ind, arr</span>) =></span> val * <span class="hljs-number">2</span>);
<span class="hljs-comment">// resultElements: [2, 4, 6, 8, 10]</span>
</code></pre>
<p><strong>filter:</strong></p>
<p>To filter some collection with given predicate and return result as a new array, use <code>filter</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elemsToFilter = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-keyword">const</span> filtered = elemsToFilter
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">val, ind, arr</span>) =></span> val % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);
<span class="hljs-comment">// filtered: [2, 4, 6, 8]</span>
</code></pre>
<p><strong>reduce:</strong></p>
<p>
  When you need to calculate some single value from whole collection values(reduce) it is a usecase
  for <code>reduce</code> method. For example, when we need to calculate sum of all array numbers:
</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
<span class="hljs-keyword">const</span> sum = numbers
  .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, curr, ind, arra</span>) =></span> prev + curr, <span class="hljs-number">0</span>);
<span class="hljs-comment">// sum: 45</span>
</code></pre>
<p>
  It accepts a reducer function, which signature contains accumulation value and current value, as
  well as usual for some other collection methods index and whole array reference. And also <code>reduce</code>
  accepts second optional value - initial accumulation value.
</p>
<h3>Sorting</h3>
<p><strong>sort:</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elemsToSort = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> sorted = elemsToSort.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> {
  <span class="hljs-keyword">if</span> (a > b) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &#x3C; b) {
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
});
<span class="hljs-comment">// sorted: [1, 2, 3, 4, 5, 6, 10]</span>
</code></pre>
<h2>Set</h2>
<p>
  <code>Set</code> is a data structure, which contains unordered and arbitrary number of unique elements. It is
  iterable, but also contains some unique methods. It does not guarantee order of stored elements and
  does not allow access to elements by index.
</p>
<p>Creting <code>Set</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1);
</code></pre>
<p>Iterating over <code>Set</code>;</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> elem <span class="hljs-keyword">of</span> s1.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem);
}
</code></pre>
<p>Cheching existence and deleting of element inside <code>Set</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (s1.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)) {
  s1.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);
}
</code></pre>
<h2>Map</h2>
<p>
  <code>Map</code> is a <code>key-value</code> data structure, where key must be a unique value. It is iterable with some
  additional methods. It does not allow acces by index. Instead values may be accessed only by it's
  keys. Unlike <code>object</code> keys may be not only of <code>string</code>, <code>number</code> or <code>symbol</code> type, but any type.
</p>
<p>
  Maps are quite similar to js objects, but unlike them maps allow any data as key and also may be
  more performant on large amount of data sets. Also maps are better on frequent inserts/removes of
  data.
</p>
<p>Creating of <code>Map</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
  [<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>],
  [<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>],
]);
</code></pre>
<p>Inserting and retrieving values:</p>
<pre><code class="hljs language-js">m1.<span class="hljs-title function_">set</span>(<span class="hljs-string">"key3"</span>, <span class="hljs-string">"value3"</span>);
<span class="hljs-keyword">const</span> value2 = m1.<span class="hljs-title function_">get</span>(<span class="hljs-string">"key2"</span>);
</code></pre>
<p>Iterating over <code>Map</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> m1.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);
}
</code></pre>
<p>
  <code>entries()</code> returns key/value pairs iterable of two elements arrays.
  But maps have also <code>keys()</code> methods, which returns iterable of only map's keys and
  <code>values()</code> method, which returns all values from map.
</p>
<p>To get size of map:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m1length = m1.<span class="hljs-property">size</span>;
</code></pre>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["javascript","js-iterables"],"note":{"title":"JS - Iterables And Collections","date":"2022-03-12","content":"\n\u003ch2\u003eIterables\u003c/h2\u003e\n\u003cp\u003e\n  In \u003ccode\u003eJS\u003c/code\u003e iterables are objects, which implement \u003ccode\u003eiterable\u003c/code\u003e protocol and have \u003ccode\u003e@@iterator\u003c/code\u003e method.\n  Those are arrays, linked lists, maps, sets, strings and so on.\n\u003c/p\u003e\n\u003cp\u003e\n  There are also \u003ccode\u003earray-like objects\u003c/code\u003e - objects, that have a length and possibility to acces it's\n  elements by index.\n\u003c/p\u003e\n\u003ch2\u003eArray\u003c/h2\u003e\n\u003cp\u003eTo create an array in \u003ccode\u003eJS\u003c/code\u003e there are many possible ways:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a1 = [\u003cspan class=\"hljs-string\"\u003e'elem'\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a2 = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'elem'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a3 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'elem'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a4 = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'elem'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a5 = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'elem'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eNote: \u003ccode\u003enew Array(5)\u003c/code\u003e or \u003ccode\u003eArray(5)\u003c/code\u003e will create new empty array with given length of 5\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003eArray.from(iterable)\u003c/code\u003e - this method is meant to convert an array-like object or iterable to an\n  actual array.\n\u003c/p\u003e\n\u003cp\u003ee.g.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// will contain ['s', 't','r', 'i', 'n', 'g'];\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eLooping Over Array\u003c/h3\u003e\n\u003cp\u003eTo loop over an iterable object we can use \u003ccode\u003efor .. of ..\u003c/code\u003e loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e iterable) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eArray Methods\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003epush:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo add an element to the end of the collection use \u003ccode\u003epush\u003c/code\u003e method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\nelems.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// will contain [1,2,3,4]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eunshift:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo add an element to the beginning of the collection use \u003ccode\u003eunshift\u003c/code\u003e method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\nelems.\u003cspan class=\"hljs-title function_\"\u003eunshift\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(elems);\n\u003cspan class=\"hljs-comment\"\u003e// will contain [0,1,2,3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003epop:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epop\u003c/code\u003e method removes last element of a collection and returns it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e lastElem = elems.\u003cspan class=\"hljs-title function_\"\u003epop\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eshift:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMethod \u003ccode\u003eshift\u003c/code\u003e removes one element from the beginning of a collection:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e firstElem = elems.\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003esplice:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  Method \u003ccode\u003esplice\u003c/code\u003e allows to remove arbitrary number of elements in the given array and replace them\n  with any number of new elements. It is an array method an can't be called on other iterables.\n\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003earr.splice(\u0026#x3C;start position\u003e, \u0026#x3C;amount of removed elements\u003e, ...\u0026#x3C;collection of elements to insert\u003e)\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\nelems.\u003cspan class=\"hljs-title function_\"\u003esplice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, ...[\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e]);\n\u003cspan class=\"hljs-comment\"\u003e// result elems =\u003e [1, 5, 6]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is also possible to remove elements counting from the tail. To do this use less than 0 index:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eelems.\u003cspan class=\"hljs-title function_\"\u003esplice\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// result elems =\u003e [1, 7, 6]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eslice:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eslice\u003c/code\u003e method allows to create a copy of some part of the array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems1 = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elemsCopy = elems1.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// elemsCopy: [3, 4]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is also possible to use negative indexes to count from the tail of the collection.\u003c/p\u003e\n\u003cp\u003eNot specifying range will copy the entire array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems1 = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fullCopy = elems1.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003econcat:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003econcat\u003c/code\u003e method accepts another collection and return as a result new array, where current and\n  given array are concatenated together. It does not change original array.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eindexOf:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003eindexOf\u003c/code\u003e allows to find index of specified element in the collection. Second argument allows to\n  define starting position to search. If specified, any previous hits will not be counted.\n  If nothing found result will be \u003ccode\u003e-1\u003c/code\u003e.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elemsToSearch = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e i = elemsToSearch.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// `i` will be 5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eincludes:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAllows to check wheather given element exists in collection:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elems = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e exists3 = elems.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eImportant to notice, that it will work with value types, because equality of reference types\nwords differently\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003elastIndexOf:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003elastIndexOf\u003c/code\u003e has the same functionality as \u003ccode\u003eindexOf\u003c/code\u003e. The only difference - it searches starting\n  from the end of the collection towards it's beginning.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003efind:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efind\u003c/code\u003e allows to search for required element in the specified array by given predicate:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e complElemsToSearch = [{ \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e }];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e foundElem = complElemsToSearch\n  .\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eval, ind, arr\u003c/span\u003e) =\u003e\u003c/span\u003e val.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Where \u003ccode\u003eval\u003c/code\u003e is a reference to the current iteration value, \u003ccode\u003eind\u003c/code\u003e - index of current iteration and\n  \u003ccode\u003earr\u003c/code\u003e is a reference to the whole array.\n\u003c/p\u003e\n\u003cp\u003e\n  It returns reference to the found object, but no it's index.\n  To search for index use \u003ccode\u003efindIndex\u003c/code\u003e method with the same signature.\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eforEach:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  This method allows to iterate over every item in the array and perform some action, specified with\n  provided function.\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elements = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\nelements.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eval, ind, arr\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`current value is \u003cspan class=\"hljs-subst\"\u003e${val}\u003c/span\u003e`\u003c/span\u003e);\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003emap:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  If there is a need to perform some action on every element of a collection and store results in a\n  new collection, it can't acheived with \u003ccode\u003emap\u003c/code\u003e method:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elements = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resultElements = elements\n  .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eval, ind, arr\u003c/span\u003e) =\u003e\u003c/span\u003e val * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// resultElements: [2, 4, 6, 8, 10]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003efilter:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo filter some collection with given predicate and return result as a new array, use \u003ccode\u003efilter\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elemsToFilter = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e filtered = elemsToFilter\n  .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eval, ind, arr\u003c/span\u003e) =\u003e\u003c/span\u003e val % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// filtered: [2, 4, 6, 8]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ereduce:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n  When you need to calculate some single value from whole collection values(reduce) it is a usecase\n  for \u003ccode\u003ereduce\u003c/code\u003e method. For example, when we need to calculate sum of all array numbers:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = numbers\n  .\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprev, curr, ind, arra\u003c/span\u003e) =\u003e\u003c/span\u003e prev + curr, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// sum: 45\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  It accepts a reducer function, which signature contains accumulation value and current value, as\n  well as usual for some other collection methods index and whole array reference. And also \u003ccode\u003ereduce\u003c/code\u003e\n  accepts second optional value - initial accumulation value.\n\u003c/p\u003e\n\u003ch3\u003eSorting\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003esort:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elemsToSort = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sorted = elemsToSort.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (a \u003e b) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (a \u0026#x3C; b) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n});\n\u003cspan class=\"hljs-comment\"\u003e// sorted: [1, 2, 3, 4, 5, 6, 10]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSet\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003eSet\u003c/code\u003e is a data structure, which contains unordered and arbitrary number of unique elements. It is\n  iterable, but also contains some unique methods. It does not guarantee order of stored elements and\n  does not allow access to elements by index.\n\u003c/p\u003e\n\u003cp\u003eCreting \u003ccode\u003eSet\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e s1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(s1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIterating over \u003ccode\u003eSet\u003c/code\u003e;\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elem \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e s1.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e()) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(elem);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCheching existence and deleting of element inside \u003ccode\u003eSet\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (s1.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)) {\n  s1.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMap\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003eMap\u003c/code\u003e is a \u003ccode\u003ekey-value\u003c/code\u003e data structure, where key must be a unique value. It is iterable with some\n  additional methods. It does not allow acces by index. Instead values may be accessed only by it's\n  keys. Unlike \u003ccode\u003eobject\u003c/code\u003e keys may be not only of \u003ccode\u003estring\u003c/code\u003e, \u003ccode\u003enumber\u003c/code\u003e or \u003ccode\u003esymbol\u003c/code\u003e type, but any type.\n\u003c/p\u003e\n\u003cp\u003e\n  Maps are quite similar to js objects, but unlike them maps allow any data as key and also may be\n  more performant on large amount of data sets. Also maps are better on frequent inserts/removes of\n  data.\n\u003c/p\u003e\n\u003cp\u003eCreating of \u003ccode\u003eMap\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e m1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e([\n  [\u003cspan class=\"hljs-string\"\u003e\"key1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value1\"\u003c/span\u003e],\n  [\u003cspan class=\"hljs-string\"\u003e\"key2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value2\"\u003c/span\u003e],\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInserting and retrieving values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003em1.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"key3\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value3\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value2 = m1.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"key2\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIterating over \u003ccode\u003eMap\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [key, value] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e m1.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e()) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(key, value);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  \u003ccode\u003eentries()\u003c/code\u003e returns key/value pairs iterable of two elements arrays.\n  But maps have also \u003ccode\u003ekeys()\u003c/code\u003e methods, which returns iterable of only map's keys and\n  \u003ccode\u003evalues()\u003c/code\u003e method, which returns all values from map.\n\u003c/p\u003e\n\u003cp\u003eTo get size of map:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e m1length = m1.\u003cspan class=\"hljs-property\"\u003esize\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["javascript","js-iterables"]},"buildId":"6V8_yxN3djhrhbRemYkax","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>