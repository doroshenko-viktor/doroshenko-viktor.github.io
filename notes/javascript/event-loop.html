<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>JavaScript Event Loop</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/mM9R5eh6xGXzeLZgOe4Us/_buildManifest.js" defer=""></script><script src="/_next/static/mM9R5eh6xGXzeLZgOe4Us/_ssgManifest.js" defer=""></script><script src="/_next/static/mM9R5eh6xGXzeLZgOe4Us/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">JavaScript Event Loop</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  <code>JavaScript</code> is a generally single threaded programming language. It is possible to achieve some level
  of concurrency with working threads. But anyway, to run them whole new runtime will be risen.
  This way any long processing will block execution of whole program. But some long running tasks do not
  require CPU computation. In their count for example <code>IO</code> operations and timeouts or handling events.
  While waiting for a database response, program could continue some of it's processes.
</p>
<p>
  Event loop in <code>JS</code> allows to perform such operations asynchronously. In simple words program can start
  such long running task, which does not require CPU computation give it to the environment and immediately
  continue to work on further instructions not waiting for completion of this task. Environment takes care of
  completing task and once it happened return the result to main program through event loop. Tasks taken by
  environment are executed in separate threads, but outside of main program runtime. This way program single threaded runtime called <code>main thread</code>.
</p>
<p>
  <code>JS environment</code> may differ from the context of execution. It may be a browser api for the frontend or
  <code>libuv</code> in <code>node.js</code>.
</p>
<p>
  Basically <code>event loop</code> is an infinite loop, which waits until main thread stack is empty, then trying to take
  a task from the task queue.
  It takes oldest task, places it into the main thread stack and the process loops. If there is no tasks in the queue,
  <code>event loop</code> simply waits until they appear. Any user or system event ocurred and created new task in the queue.
</p>
<p>While waiting for tasks to appear, event loop is very efficient in terms of CPU usage.</p>
<h2>How It Works In Details</h2>
<p>Simplest example:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1'</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2'</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3'</span>);
</code></pre>
<p>
  Here <code>console.log('1');</code> is a synchronous function call, which will be executed immediately and print <code>1</code>
  into the console. Next instruction <code>setTimeout</code> is asynchronous function call. It will create a task
  in the environment, which should wait for a given period of time(in this case 0 seconds) and run code inside
  of a given callback function.
</p>
<p>
  As <code>setTimeout</code> is an <code>async</code> function, it's only job is to create a task in the <code>JS</code> environment. Our program
  will do only this on it's way and will go to the next instruction.
</p>
<p><em>And it does not matter that, timeout is 0, the way is always the same - create task and go further.</em></p>
<p>Next instruction is <code>console.log('3');</code>, which is also synchronous and will print <code>3</code> to the console.</p>
<p>Now we have following output in our console:</p>
<pre><code class="hljs language-txt">1
3
</code></pre>
<p>
  But program didn't finish it's execution. We still have task, created by <code>setTimeout</code>. It is running in
  parallel to the main program inside of <code>JS</code> environment. And while timeout was 0 it is already completed.
  But to print <code>2</code> to the console it should go through couple of steps in event loop.
</p>
<p>
  Event loop is kind of a <code>FIFO queue</code>. When <code>async</code> task is finished, environment places result callback to
  the end of the event loop. When current call stack is empty, our program checks, if something appeared in
  the event loop. If it is not empty first or in another words oldest item will be taken and placed to the
  call stack.
</p>
<p>
  On this step, when two <code>console.log</code> instructions have already been executed and printed <code>1</code> and <code>3</code>,
  call stack of our program is empty. So it checks if there is something in the event loop. And luckily
  there is a task to call function:
</p>
<pre><code class="hljs language-js">() => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2'</span>);
}
</code></pre>
<p>
  Which was provided to <code>setTimeout</code> when main program executed it and then, after async task has been
  completed placed to the event loop by the environment. Now main program moves it to the stack and executes
  <code>console.log('2');</code> instruction, which will print <code>2</code> to the console.
</p>
<h2>Events</h2>
<p>
  When some events happening, they don't go directly to call stack. Same as with async tasks all events go
  through event loop queue. For example, if <code>onclick</code> event risen after button click it is queued in event
  loop. Which means that it will be handled only after current call stack will be cleared. This may be a
  reason of delays of event handling if we are blocking main thread.
</p>
<h2>Browser Rendering</h2>
<p>Browser renders displaying picture also as a part of an event loop.</p>
<p>
  Same as for events applies to rendering. There are several steps browser makes to render a picture on a
  display. But these steps are also a part of the event loop. So if we run blocking code in the stack, rendering
  also could stuck.
</p>
<p>Rendering steps are:</p>
<ul>
  <li><code>style</code> - calculate colors, sizes, fonts and other <code>css</code> and assign them to elements</li>
  <li><code>layout</code> - apply position to all elements</li>
  <li><code>paint</code> - using graphics library, create precise image</li>
</ul>
<p>
  Result of these steps is <code>Frame</code> - array of pixels, which will be directly displayed on the user screen.
  If the <code>DOM</code> has been changed, browser has to execute all 3 steps and regenerate <code>Frame</code>.
</p>
<p>
  But while rendering steps are part of event loop, they have higher priority than other tasks. Event if event
  queue already contains some scheduled events, rendering steps will be performed before them.
</p>
<p>Ideally when there is no blocking tasks, render steps are executed 60 times per second.</p>
<h3>Rendering With <code>requestAnimationFrame</code></h3>
<p>
  If you need to make a changes related to rendering to the display it there is a special method for this -
  <code>requestAnimationFrame</code>. It is called immediately before rendering steps. The reason, why it is better to
  use this method, instead of queuing a task - it is predictable. It runs regularly with target to create
  60 frames per second. Task can be executed in event loop in any time causing uncontrollable behavior of a
  picture. Tasks may cause rerendering with a random frame rate.
</p>
<p>
  For example, using <code>setTimeout</code> for animation we may schedule several update per single frame, which is a
  waste of a computational power. Moreover, as this is not designed for animation event if we trying to
  schedule tasks to recalculate picture once per frame, there still could be some misses, e.g. garbage
  collection started and such task will not hit necessary frame, but on the next frame we will have two
  calculations.
</p>
<h2>Microtasks</h2>
<p>
  The main difference of <code>microtask</code> from regular task is in queue consumption. While main task queue executes
  task one by one and allows page rendering stages between them, microtask queue when started execution, blocks
  the main thread until all microtask queue will not be empty. This is useful, when we need to schedule next
  task and ensure it will be handled before next rerender phase.
</p>
<p><code>Promises</code> internally implemented using microtasks.</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">"1"</span>));
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">"2"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"3"</span>);
</code></pre>
<p>this example will print</p>
<pre><code class="hljs language-txt">3
2
1
</code></pre>
<p>
  to the console. This is happening because <code>setTimeout</code> schedules regular task and <code>Promise</code> creates a microtask,
  which has priority over macrotasks.
</p>
<p>
  If we need to ensure, that application state will not be changed after we schedule a task, we can use <code>queueMicrotask</code>
  function. It will create a new task in microtask queue, which will have a priority over all other tasks, such as
  event listeners and macrotasks.
</p>
<h2>Performance Tips</h2>
<p>
  When there is a need to perform some heavy calculation, which may potentially block the main thread it may
  be a good idea to split it in time. For example using <code>setTimeout</code> with <code>0</code> delay. This will reschedule some
  part of heavy code into the event loop task queue, which will introduce possibility for rerendering the
  content of the page.
</p>
<p>Such separation does not make a big difference in overall heavy calculation time, but increases page responsiveness.</p>
<p>
  Another option is separating heavy calculation to the working thread. Such a way we can introduce some kind
  of multithreading. Our main thread will execute only light tasks and rendering, while blocking calculation
  in working thread will not affect page responsiveness.
</p>
<h2>References</h2>
<ul>
  <li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li>
  <li><a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a></li>
  <li><a href="https://javascript.info/event-loop">https://javascript.info/event-loop</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["javascript","event-loop"],"note":{"title":"JavaScript Event Loop","date":"2022-06-18","content":"\n\u003cp\u003e\n  \u003ccode\u003eJavaScript\u003c/code\u003e is a generally single threaded programming language. It is possible to achieve some level\n  of concurrency with working threads. But anyway, to run them whole new runtime will be risen.\n  This way any long processing will block execution of whole program. But some long running tasks do not\n  require CPU computation. In their count for example \u003ccode\u003eIO\u003c/code\u003e operations and timeouts or handling events.\n  While waiting for a database response, program could continue some of it's processes.\n\u003c/p\u003e\n\u003cp\u003e\n  Event loop in \u003ccode\u003eJS\u003c/code\u003e allows to perform such operations asynchronously. In simple words program can start\n  such long running task, which does not require CPU computation give it to the environment and immediately\n  continue to work on further instructions not waiting for completion of this task. Environment takes care of\n  completing task and once it happened return the result to main program through event loop. Tasks taken by\n  environment are executed in separate threads, but outside of main program runtime. This way program single threaded runtime called \u003ccode\u003emain thread\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  \u003ccode\u003eJS environment\u003c/code\u003e may differ from the context of execution. It may be a browser api for the frontend or\n  \u003ccode\u003elibuv\u003c/code\u003e in \u003ccode\u003enode.js\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  Basically \u003ccode\u003eevent loop\u003c/code\u003e is an infinite loop, which waits until main thread stack is empty, then trying to take\n  a task from the task queue.\n  It takes oldest task, places it into the main thread stack and the process loops. If there is no tasks in the queue,\n  \u003ccode\u003eevent loop\u003c/code\u003e simply waits until they appear. Any user or system event ocurred and created new task in the queue.\n\u003c/p\u003e\n\u003cp\u003eWhile waiting for tasks to appear, event loop is very efficient in terms of CPU usage.\u003c/p\u003e\n\u003ch2\u003eHow It Works In Details\u003c/h2\u003e\n\u003cp\u003eSimplest example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e);\n}, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'3'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Here \u003ccode\u003econsole.log('1');\u003c/code\u003e is a synchronous function call, which will be executed immediately and print \u003ccode\u003e1\u003c/code\u003e\n  into the console. Next instruction \u003ccode\u003esetTimeout\u003c/code\u003e is asynchronous function call. It will create a task\n  in the environment, which should wait for a given period of time(in this case 0 seconds) and run code inside\n  of a given callback function.\n\u003c/p\u003e\n\u003cp\u003e\n  As \u003ccode\u003esetTimeout\u003c/code\u003e is an \u003ccode\u003easync\u003c/code\u003e function, it's only job is to create a task in the \u003ccode\u003eJS\u003c/code\u003e environment. Our program\n  will do only this on it's way and will go to the next instruction.\n\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eAnd it does not matter that, timeout is 0, the way is always the same - create task and go further.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eNext instruction is \u003ccode\u003econsole.log('3');\u003c/code\u003e, which is also synchronous and will print \u003ccode\u003e3\u003c/code\u003e to the console.\u003c/p\u003e\n\u003cp\u003eNow we have following output in our console:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-txt\"\u003e1\n3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  But program didn't finish it's execution. We still have task, created by \u003ccode\u003esetTimeout\u003c/code\u003e. It is running in\n  parallel to the main program inside of \u003ccode\u003eJS\u003c/code\u003e environment. And while timeout was 0 it is already completed.\n  But to print \u003ccode\u003e2\u003c/code\u003e to the console it should go through couple of steps in event loop.\n\u003c/p\u003e\n\u003cp\u003e\n  Event loop is kind of a \u003ccode\u003eFIFO queue\u003c/code\u003e. When \u003ccode\u003easync\u003c/code\u003e task is finished, environment places result callback to\n  the end of the event loop. When current call stack is empty, our program checks, if something appeared in\n  the event loop. If it is not empty first or in another words oldest item will be taken and placed to the\n  call stack.\n\u003c/p\u003e\n\u003cp\u003e\n  On this step, when two \u003ccode\u003econsole.log\u003c/code\u003e instructions have already been executed and printed \u003ccode\u003e1\u003c/code\u003e and \u003ccode\u003e3\u003c/code\u003e,\n  call stack of our program is empty. So it checks if there is something in the event loop. And luckily\n  there is a task to call function:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e() =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Which was provided to \u003ccode\u003esetTimeout\u003c/code\u003e when main program executed it and then, after async task has been\n  completed placed to the event loop by the environment. Now main program moves it to the stack and executes\n  \u003ccode\u003econsole.log('2');\u003c/code\u003e instruction, which will print \u003ccode\u003e2\u003c/code\u003e to the console.\n\u003c/p\u003e\n\u003ch2\u003eEvents\u003c/h2\u003e\n\u003cp\u003e\n  When some events happening, they don't go directly to call stack. Same as with async tasks all events go\n  through event loop queue. For example, if \u003ccode\u003eonclick\u003c/code\u003e event risen after button click it is queued in event\n  loop. Which means that it will be handled only after current call stack will be cleared. This may be a\n  reason of delays of event handling if we are blocking main thread.\n\u003c/p\u003e\n\u003ch2\u003eBrowser Rendering\u003c/h2\u003e\n\u003cp\u003eBrowser renders displaying picture also as a part of an event loop.\u003c/p\u003e\n\u003cp\u003e\n  Same as for events applies to rendering. There are several steps browser makes to render a picture on a\n  display. But these steps are also a part of the event loop. So if we run blocking code in the stack, rendering\n  also could stuck.\n\u003c/p\u003e\n\u003cp\u003eRendering steps are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003estyle\u003c/code\u003e - calculate colors, sizes, fonts and other \u003ccode\u003ecss\u003c/code\u003e and assign them to elements\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003elayout\u003c/code\u003e - apply position to all elements\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003epaint\u003c/code\u003e - using graphics library, create precise image\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  Result of these steps is \u003ccode\u003eFrame\u003c/code\u003e - array of pixels, which will be directly displayed on the user screen.\n  If the \u003ccode\u003eDOM\u003c/code\u003e has been changed, browser has to execute all 3 steps and regenerate \u003ccode\u003eFrame\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  But while rendering steps are part of event loop, they have higher priority than other tasks. Event if event\n  queue already contains some scheduled events, rendering steps will be performed before them.\n\u003c/p\u003e\n\u003cp\u003eIdeally when there is no blocking tasks, render steps are executed 60 times per second.\u003c/p\u003e\n\u003ch3\u003eRendering With \u003ccode\u003erequestAnimationFrame\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\n  If you need to make a changes related to rendering to the display it there is a special method for this -\n  \u003ccode\u003erequestAnimationFrame\u003c/code\u003e. It is called immediately before rendering steps. The reason, why it is better to\n  use this method, instead of queuing a task - it is predictable. It runs regularly with target to create\n  60 frames per second. Task can be executed in event loop in any time causing uncontrollable behavior of a\n  picture. Tasks may cause rerendering with a random frame rate.\n\u003c/p\u003e\n\u003cp\u003e\n  For example, using \u003ccode\u003esetTimeout\u003c/code\u003e for animation we may schedule several update per single frame, which is a\n  waste of a computational power. Moreover, as this is not designed for animation event if we trying to\n  schedule tasks to recalculate picture once per frame, there still could be some misses, e.g. garbage\n  collection started and such task will not hit necessary frame, but on the next frame we will have two\n  calculations.\n\u003c/p\u003e\n\u003ch2\u003eMicrotasks\u003c/h2\u003e\n\u003cp\u003e\n  The main difference of \u003ccode\u003emicrotask\u003c/code\u003e from regular task is in queue consumption. While main task queue executes\n  task one by one and allows page rendering stages between them, microtask queue when started execution, blocks\n  the main thread until all microtask queue will not be empty. This is useful, when we need to schedule next\n  task and ensure it will be handled before next rerender phase.\n\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePromises\u003c/code\u003e internally implemented using microtasks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e));\n\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2\"\u003c/span\u003e));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"3\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethis example will print\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-txt\"\u003e3\n2\n1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  to the console. This is happening because \u003ccode\u003esetTimeout\u003c/code\u003e schedules regular task and \u003ccode\u003ePromise\u003c/code\u003e creates a microtask,\n  which has priority over macrotasks.\n\u003c/p\u003e\n\u003cp\u003e\n  If we need to ensure, that application state will not be changed after we schedule a task, we can use \u003ccode\u003equeueMicrotask\u003c/code\u003e\n  function. It will create a new task in microtask queue, which will have a priority over all other tasks, such as\n  event listeners and macrotasks.\n\u003c/p\u003e\n\u003ch2\u003ePerformance Tips\u003c/h2\u003e\n\u003cp\u003e\n  When there is a need to perform some heavy calculation, which may potentially block the main thread it may\n  be a good idea to split it in time. For example using \u003ccode\u003esetTimeout\u003c/code\u003e with \u003ccode\u003e0\u003c/code\u003e delay. This will reschedule some\n  part of heavy code into the event loop task queue, which will introduce possibility for rerendering the\n  content of the page.\n\u003c/p\u003e\n\u003cp\u003eSuch separation does not make a big difference in overall heavy calculation time, but increases page responsiveness.\u003c/p\u003e\n\u003cp\u003e\n  Another option is separating heavy calculation to the working thread. Such a way we can introduce some kind\n  of multithreading. Our main thread will execute only light tasks and rendering, while blocking calculation\n  in working thread will not affect page responsiveness.\n\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\"\u003ehttps://www.youtube.com/watch?v=8aGhZQkoFbQ\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\"\u003ehttps://www.youtube.com/watch?v=cCOL7MC4Pl0\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://javascript.info/event-loop\"\u003ehttps://javascript.info/event-loop\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["javascript","event-loop"]},"buildId":"mM9R5eh6xGXzeLZgOe4Us","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>