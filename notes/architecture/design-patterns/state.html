<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>State Pattern</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b2e3df602701a6f2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b2e3df602701a6f2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ca60bdbe6d2fe4f6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ca60bdbe6d2fe4f6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/369-aaa550419eab31e8.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-c40409aa5ea3ea66.js" defer=""></script><script src="/_next/static/_zFDLGWjM7-LaUQPOYFqf/_buildManifest.js" defer=""></script><script src="/_next/static/_zFDLGWjM7-LaUQPOYFqf/_ssgManifest.js" defer=""></script><script src="/_next/static/_zFDLGWjM7-LaUQPOYFqf/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><div><a href="/"><header class="Header_mainHeader__VLamk Header_mainHeaderS__9KEas"><div class="Header_mainLogoImg__eX6Vr"><img src="/images/profile-pic.png" alt="logo"/></div><h1 class="Header_blogName__4JblC">Tech Notes</h1></header></a></div><h1 class="NoteFormattedContent_noteTitle__Oi9sD">State Pattern</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  <code>State</code> object oriented design pattern is useful, when object should frequently change it's behavior
  depending on it's current state.
</p>
<p>At any point in time object may have certain state, which will affect it's behavior. Object can change it's state, but this change have to be valid according to defined transition rules. In other words object defines it's rules for state transitions and validates any state transition. So some state changes may be applied and some rejected.</p>
<p>
  Usually these transition is a some kind of <code>Finite State Machine</code>. In simplest solution transition rules are implemented with <code>switch</code> or trees of <code>if/else</code> conditions.
  When amount of states is big or, when we frequently add new behavior, it is not only becomes hard to manage such code, but there will be much higher chance of an error.
</p>
<h2>When To Use</h2>
<p>
  <code>State</code> pattern is useful, when object has some set of methods and behavior of these methods should vary depending on a state this object currently has.
  Important to note that <code>State</code> pattern is applicable, when all of object behavior methods are applicable in all states, but behave differently.
</p>
<p>It follows <code>Single Responsibility</code> and <code>Open/Closed</code> principles. When adding new behavior, we need to add new state classes, but not required to change much of existing codebase. When some of the states requirement changes, only particular state logic will be required to be changed not affecting other states.</p>
<p>
  But even if applicable, using state may be an over-engineering in simple scenarios with little concrete
  states amount and when logic depending on this states changes not very often. It is always worth to analyze if using the pattern will solve a problem in a more efficient way, than it is already implemented.
</p>
<h2>Implementation</h2>
<p>
  Following <code>State</code> design pattern, we need to create new object which will encapsulate general object behavior. This object called <code>context</code>.
  And create separate objects, which represent each <code>state</code> of parent object. All of the state objects
  must implement common state interface. It may be particular language construction, like <code>interface</code>
  in C# and Java or simply have same methods for dynamic languages.
  <code>Context</code> contains single object of <code>State</code> interface, which represents current object state.
</p>
<p><code>Context</code> object should have special method for changing it's state and it will receive <code>state</code> objects.</p>
<p><code>State</code> methods should be applicable for all possible object state, but their behavior on different states may vary.</p>
<p>
  It is allowed for <code>state</code> to have back reference to it's parent <code>context</code>. Such a way state may receive
  some data from the context.
</p>
<h2>References</h2>
<ul>
  <li><a href="https://refactoring.guru/design-patterns/state">Refactoring Guru</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Finite-state_machine#UML_state_machines">Finite State Machine</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["architecture","design-patterns","state"],"note":{"title":"State Pattern","date":"2022-05-13","content":"\n\u003cp\u003e\n  \u003ccode\u003eState\u003c/code\u003e object oriented design pattern is useful, when object should frequently change it's behavior\n  depending on it's current state.\n\u003c/p\u003e\n\u003cp\u003eAt any point in time object may have certain state, which will affect it's behavior. Object can change it's state, but this change have to be valid according to defined transition rules. In other words object defines it's rules for state transitions and validates any state transition. So some state changes may be applied and some rejected.\u003c/p\u003e\n\u003cp\u003e\n  Usually these transition is a some kind of \u003ccode\u003eFinite State Machine\u003c/code\u003e. In simplest solution transition rules are implemented with \u003ccode\u003eswitch\u003c/code\u003e or trees of \u003ccode\u003eif/else\u003c/code\u003e conditions.\n  When amount of states is big or, when we frequently add new behavior, it is not only becomes hard to manage such code, but there will be much higher chance of an error.\n\u003c/p\u003e\n\u003ch2\u003eWhen To Use\u003c/h2\u003e\n\u003cp\u003e\n  \u003ccode\u003eState\u003c/code\u003e pattern is useful, when object has some set of methods and behavior of these methods should vary depending on a state this object currently has.\n  Important to note that \u003ccode\u003eState\u003c/code\u003e pattern is applicable, when all of object behavior methods are applicable in all states, but behave differently.\n\u003c/p\u003e\n\u003cp\u003eIt follows \u003ccode\u003eSingle Responsibility\u003c/code\u003e and \u003ccode\u003eOpen/Closed\u003c/code\u003e principles. When adding new behavior, we need to add new state classes, but not required to change much of existing codebase. When some of the states requirement changes, only particular state logic will be required to be changed not affecting other states.\u003c/p\u003e\n\u003cp\u003e\n  But even if applicable, using state may be an over-engineering in simple scenarios with little concrete\n  states amount and when logic depending on this states changes not very often. It is always worth to analyze if using the pattern will solve a problem in a more efficient way, than it is already implemented.\n\u003c/p\u003e\n\u003ch2\u003eImplementation\u003c/h2\u003e\n\u003cp\u003e\n  Following \u003ccode\u003eState\u003c/code\u003e design pattern, we need to create new object which will encapsulate general object behavior. This object called \u003ccode\u003econtext\u003c/code\u003e.\n  And create separate objects, which represent each \u003ccode\u003estate\u003c/code\u003e of parent object. All of the state objects\n  must implement common state interface. It may be particular language construction, like \u003ccode\u003einterface\u003c/code\u003e\n  in C# and Java or simply have same methods for dynamic languages.\n  \u003ccode\u003eContext\u003c/code\u003e contains single object of \u003ccode\u003eState\u003c/code\u003e interface, which represents current object state.\n\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eContext\u003c/code\u003e object should have special method for changing it's state and it will receive \u003ccode\u003estate\u003c/code\u003e objects.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState\u003c/code\u003e methods should be applicable for all possible object state, but their behavior on different states may vary.\u003c/p\u003e\n\u003cp\u003e\n  It is allowed for \u003ccode\u003estate\u003c/code\u003e to have back reference to it's parent \u003ccode\u003econtext\u003c/code\u003e. Such a way state may receive\n  some data from the context.\n\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://refactoring.guru/design-patterns/state\"\u003eRefactoring Guru\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Finite-state_machine#UML_state_machines\"\u003eFinite State Machine\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["architecture","design-patterns","state"]},"buildId":"_zFDLGWjM7-LaUQPOYFqf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>