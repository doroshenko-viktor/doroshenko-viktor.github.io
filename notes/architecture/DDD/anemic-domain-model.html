<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Anemic Domain Model</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_buildManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_ssgManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Anemic Domain Model</h1><article class="NoteFormattedContent_note__8cHeE">
<p>
  <code>Anemic Domain Model</code> is a such domain model, which contains no or very little of business logic.
  Usually this appears as domain model in simple type with all open fields and no behavior. In such
  cases all business logic lives in separate services, which use domain model public fields to get
  data for it's manipulation.
</p>
<p>
  Main downside of this approach is code duplication. When we have a single domain model and various
  use case services, which use it and implement business logic tightly related to this model it is
  inevitably leads to duplication of this logic in different use cases. Than later, when our requirements
  on this logic will change it may cause issues, because we need to change all places, where this
  duplicated logic exists. It is highly possible, that we will change not all instances of this logic.
  This also raises cognitive complexity, because we need to remember <code>n</code> business logic variants in <code>m</code> use cases.
</p>
<p>
  When domain related logic is placed near to the domain entity we reduce duplication and make future
  changes easier and less error prone. It is always easy to start searching for some business logic in
  a singe domain entity, than exploring whole bunch of use cases.
</p>
<p>
  This means, that those logic, which is highly related to the business object itself should be placed
  directly inside this business entity and those logic, which may not be placed into entity, but still
  related to it, like validation, should be placed inside domain service and not on application layer.
</p>
<p>
  In application layer there should be only logic related to particular use cases, which can't be
  encapsulated or reused by other services.
</p>
<p>
  And logic related to external resources, like databases, queues, calls to external services, should
  be placed inside infrastructure layer.
</p>
<p>
  The downside of this separation is of course - implementation time. So it is always good to analyze
  if benefits of <code>rich domain model</code> worth time spent on it's implementation. In cases, when this is
  a one-time use application, prototyping, proof of concept it is likely that <code>anemic domain model</code>
  has it's benefits of fast implementation.
</p>
<h2>Resources</h2>
<ul>
  <li><a href="https://khalilstemmler.com/wiki/anemic-domain-model/">Anemic Domain Model</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["architecture","DDD","anemic-domain-model"],"note":{"title":"Anemic Domain Model","date":"2022-05-24","content":"\n\u003cp\u003e\n  \u003ccode\u003eAnemic Domain Model\u003c/code\u003e is a such domain model, which contains no or very little of business logic.\n  Usually this appears as domain model in simple type with all open fields and no behavior. In such\n  cases all business logic lives in separate services, which use domain model public fields to get\n  data for it's manipulation.\n\u003c/p\u003e\n\u003cp\u003e\n  Main downside of this approach is code duplication. When we have a single domain model and various\n  use case services, which use it and implement business logic tightly related to this model it is\n  inevitably leads to duplication of this logic in different use cases. Than later, when our requirements\n  on this logic will change it may cause issues, because we need to change all places, where this\n  duplicated logic exists. It is highly possible, that we will change not all instances of this logic.\n  This also raises cognitive complexity, because we need to remember \u003ccode\u003en\u003c/code\u003e business logic variants in \u003ccode\u003em\u003c/code\u003e use cases.\n\u003c/p\u003e\n\u003cp\u003e\n  When domain related logic is placed near to the domain entity we reduce duplication and make future\n  changes easier and less error prone. It is always easy to start searching for some business logic in\n  a singe domain entity, than exploring whole bunch of use cases.\n\u003c/p\u003e\n\u003cp\u003e\n  This means, that those logic, which is highly related to the business object itself should be placed\n  directly inside this business entity and those logic, which may not be placed into entity, but still\n  related to it, like validation, should be placed inside domain service and not on application layer.\n\u003c/p\u003e\n\u003cp\u003e\n  In application layer there should be only logic related to particular use cases, which can't be\n  encapsulated or reused by other services.\n\u003c/p\u003e\n\u003cp\u003e\n  And logic related to external resources, like databases, queues, calls to external services, should\n  be placed inside infrastructure layer.\n\u003c/p\u003e\n\u003cp\u003e\n  The downside of this separation is of course - implementation time. So it is always good to analyze\n  if benefits of \u003ccode\u003erich domain model\u003c/code\u003e worth time spent on it's implementation. In cases, when this is\n  a one-time use application, prototyping, proof of concept it is likely that \u003ccode\u003eanemic domain model\u003c/code\u003e\n  has it's benefits of fast implementation.\n\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://khalilstemmler.com/wiki/anemic-domain-model/\"\u003eAnemic Domain Model\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["architecture","DDD","anemic-domain-model"]},"buildId":"TLVs-fHNJx4QzHIHhPfMV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>