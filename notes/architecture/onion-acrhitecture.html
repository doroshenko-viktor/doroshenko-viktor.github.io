<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Onion Architecture</title><link rel="icon" href="/images/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/b65b5b41f2379875.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b65b5b41f2379875.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0d9654b911e08999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0d9654b911e08999.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-85d7488a393e293e.js" defer=""></script><script src="/_next/static/chunks/211-ca3cd870e26e881a.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5B...noteKey%5D-bc6552c3ae1e3718.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_buildManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_ssgManifest.js" defer=""></script><script src="/_next/static/TLVs-fHNJx4QzHIHhPfMV/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="Layout_centeredSection__nmU9U"><ul class="NavigationBar_navbar__CBMoV"><li class="NavigationBar_navitem__LKB5F"><a class="NavigationBar_navitemContent__jEyWq" href="/">Home</a><span class="NavigationBar_separator__qvEVD">|</span></li><li class="NavigationBar_navitem__LKB5F"><button class="NavigationBar_navitemContent__jEyWq">Back</button><span class="NavigationBar_separator__qvEVD">|</span></li></ul><h1 class="NoteFormattedContent_noteTitle__Oi9sD">Onion Architecture</h1><article class="NoteFormattedContent_note__8cHeE">
<h2>Description</h2>
<p>
  Coupling is a common software development problem. It reduces ability to maintain and change system
  following changed requirements. While coupling is a fundamental problem, it is not possible to eliminate it in the software system. But it is possible to reduce coupling by eliminating those kinds of it, which does not bring any advantages. Necessary coupling is directed from less important and frequently changed components to the most valuable and stable components which contain main value of application.
</p>
<p>Usually application can be divided to core business logic, which is responsible for solving real world problems, saving time, money. Sometimes it is easy to recognise this logic by the fact, that it may be not automated with computer systems and implemented in other way. Like accountant may calculate balance with or without computer. Computer system just makes this faster and easier.</p>
<p>The second part is other logic, which is required for core business functionality to exist. It connects business to the outer world with APIs, databases, sends messages or provides access to the file system. This layer also known as <code>infrastructure</code>. Saying differently infrastructure functionality is such code, that is required for application to operate, but does not provide any competitieve advantages for it.</p>
<p>
  It is very likely that infrastructure layer functionality changes more often, than core business. We can
  change databases, messaging systems, we even can deside to change architecture and replace file system calls with third party provided database products, change native application to be web based e.t.c. In all such cases core business not changes. But if we couple out business to infrastructre, making such
  changes will be hard if in some cases even possible. Such a way we can make changes to the system with less pain. Inversion of dependencies also makes application framework agnostic. All framework, database, connectivity and other not core logic becomes just a plugin for our core domain.
</p>
<p>Domain models and business functionality in the center. Other layers are surround core. Dependencies are directed towards the center. Amount of layes may vary. But the principle, when of dependencies is always the same.</p>
<p>The typical layer structure consists of 4 layers:</p>
<ul>
  <li><code>Domain</code>: business objects</li>
  <li><code>Application</code>: usecases and concrete interface to business</li>
  <li><code>Infrastructure</code>: databases, external service connectivity, file system...</li>
  <li><code>UI</code>: frameworks, web, CLI or other ways to use application</li>
</ul>
<p>
  <img src="/_images/onion-arch-diagram.png" alt="onion architecture diagram">
</p>
<p>
  Layers are coupled only with interfaces. For this purpose each inner level defines an interface for
  the external layer and external layer implements this interface. Later on app configuration this implementations are injected and inner level can use them through the interface. This configuration usually happend on the highest level of the application.
</p>
<p>That said onion architecture heavily relied on <code>SOLID</code> <code>Inversion of controle</code> principle.</p>
<p>
  Important to note: normally it is a good practice to make path from external layer to the objects it uses as short as possible. In other words best case scenario when layer uses object internal to it, then it can use objects from immediate neibhour(it will always be closest internal layer). Then second neibhour and deeper. Better to avoid last case. For example controller should not access business
  entities or repositories directly. But onion architecture allows all scenarios until dependencies directed towards center.
</p>
<h2>Pros</h2>
<ul>
  <li>It allows to reduce unnecessary coupling(business, infrastructure, UI, e.t.c.)</li>
  <li>Eases maintenence and growth of the system</li>
  <li>Core layers can be shipped independently from infrastructure and changing infrastructure does not affect core.</li>
</ul>
<h2>Cons</h2>
<ul>
  <li>Tied to OOP</li>
</ul>
<h2>Application Usecases</h2>
<h2>Refernces</h2>
<ul>
  <li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">The Onion Architecture : part 1</a></li>
  <li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-2/">The Onion Architecture : part 2</a></li>
  <li><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/february/best-practice-an-introduction-to-domain-driven-design">Best Practice - An Introduction To Domain-Driven Design</a></li>
</ul>
</article></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"noteKey":["architecture","onion-acrhitecture"],"note":{"title":"Onion Architecture","date":"2022-05-26","content":"\n\u003ch2\u003eDescription\u003c/h2\u003e\n\u003cp\u003e\n  Coupling is a common software development problem. It reduces ability to maintain and change system\n  following changed requirements. While coupling is a fundamental problem, it is not possible to eliminate it in the software system. But it is possible to reduce coupling by eliminating those kinds of it, which does not bring any advantages. Necessary coupling is directed from less important and frequently changed components to the most valuable and stable components which contain main value of application.\n\u003c/p\u003e\n\u003cp\u003eUsually application can be divided to core business logic, which is responsible for solving real world problems, saving time, money. Sometimes it is easy to recognise this logic by the fact, that it may be not automated with computer systems and implemented in other way. Like accountant may calculate balance with or without computer. Computer system just makes this faster and easier.\u003c/p\u003e\n\u003cp\u003eThe second part is other logic, which is required for core business functionality to exist. It connects business to the outer world with APIs, databases, sends messages or provides access to the file system. This layer also known as \u003ccode\u003einfrastructure\u003c/code\u003e. Saying differently infrastructure functionality is such code, that is required for application to operate, but does not provide any competitieve advantages for it.\u003c/p\u003e\n\u003cp\u003e\n  It is very likely that infrastructure layer functionality changes more often, than core business. We can\n  change databases, messaging systems, we even can deside to change architecture and replace file system calls with third party provided database products, change native application to be web based e.t.c. In all such cases core business not changes. But if we couple out business to infrastructre, making such\n  changes will be hard if in some cases even possible. Such a way we can make changes to the system with less pain. Inversion of dependencies also makes application framework agnostic. All framework, database, connectivity and other not core logic becomes just a plugin for our core domain.\n\u003c/p\u003e\n\u003cp\u003eDomain models and business functionality in the center. Other layers are surround core. Dependencies are directed towards the center. Amount of layes may vary. But the principle, when of dependencies is always the same.\u003c/p\u003e\n\u003cp\u003eThe typical layer structure consists of 4 layers:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eDomain\u003c/code\u003e: business objects\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eApplication\u003c/code\u003e: usecases and concrete interface to business\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eInfrastructure\u003c/code\u003e: databases, external service connectivity, file system...\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eUI\u003c/code\u003e: frameworks, web, CLI or other ways to use application\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  \u003cimg src=\"/_images/onion-arch-diagram.png\" alt=\"onion architecture diagram\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Layers are coupled only with interfaces. For this purpose each inner level defines an interface for\n  the external layer and external layer implements this interface. Later on app configuration this implementations are injected and inner level can use them through the interface. This configuration usually happend on the highest level of the application.\n\u003c/p\u003e\n\u003cp\u003eThat said onion architecture heavily relied on \u003ccode\u003eSOLID\u003c/code\u003e \u003ccode\u003eInversion of controle\u003c/code\u003e principle.\u003c/p\u003e\n\u003cp\u003e\n  Important to note: normally it is a good practice to make path from external layer to the objects it uses as short as possible. In other words best case scenario when layer uses object internal to it, then it can use objects from immediate neibhour(it will always be closest internal layer). Then second neibhour and deeper. Better to avoid last case. For example controller should not access business\n  entities or repositories directly. But onion architecture allows all scenarios until dependencies directed towards center.\n\u003c/p\u003e\n\u003ch2\u003ePros\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003eIt allows to reduce unnecessary coupling(business, infrastructure, UI, e.t.c.)\u003c/li\u003e\n  \u003cli\u003eEases maintenence and growth of the system\u003c/li\u003e\n  \u003cli\u003eCore layers can be shipped independently from infrastructure and changing infrastructure does not affect core.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCons\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003eTied to OOP\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eApplication Usecases\u003c/h2\u003e\n\u003ch2\u003eRefernces\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/\"\u003eThe Onion Architecture : part 1\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://jeffreypalermo.com/2008/07/the-onion-architecture-part-2/\"\u003eThe Onion Architecture : part 2\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/february/best-practice-an-introduction-to-domain-driven-design\"\u003eBest Practice - An Introduction To Domain-Driven Design\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/notes/[...noteKey]","query":{"noteKey":["architecture","onion-acrhitecture"]},"buildId":"TLVs-fHNJx4QzHIHhPfMV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>