{"pageProps":{"noteKey":["rust","smart-pointers"],"note":{"title":"Rust Smart Pointers","date":"2022-02-26","content":"\n<p>\n  <code>Smart pointers</code> are data structures that not only act like a pointer but also have additional\n  metadata and capabilities.\n</p>\n<p>\n  e.g. <code>String</code> and <code>Vec&#x3C;T></code> are smart pointers. They own some memory and allow to manipulate it.\n  They also have metadata (such as their capacity) and extra capabilities or guarantees (such as\n  with <code>String</code> ensuring its data will always be valid <code>UTF-8</code>).\n</p>\n<p>\n  Smart pointers are usually implemented using structs. The characteristic that distinguishes a\n  smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.\n  The <code>Deref</code> trait allows an instance of the smart pointer struct to behave like a reference so\n  you can write code that works with either references or smart pointers. The <code>Drop</code> trait allows\n  you to customize the code that is run when an instance of the smart pointer goes out of scope.\n</p>\n<p>Examples from standard library:</p>\n<ul>\n  <li><code>Box&#x3C;T></code> for allocating values on the heap</li>\n  <li><code>Rc&#x3C;T></code>, a reference counting type that enables multiple ownership</li>\n  <li>\n    <code>Ref&#x3C;T></code> and <code>RefMut&#x3C;T></code>, accessed through <code>RefCell&#x3C;T></code>, a type that enforces the borrowing\n    rules at runtime instead of compile time\n  </li>\n</ul>\n<h2>Box</h2>\n<p>\n  Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the\n  pointer to the heap data.\n</p>\n<p>They are used mostly for:</p>\n<ul>\n  <li>\n    When you have a type whose size can’t be known at compile time and you want to use a value of\n    that type in a context that requires an exact size\n  </li>\n  <li>\n    When you have a large amount of data and you want to transfer ownership but ensure the data\n    won’t be copied when you do so\n  </li>\n  <li>\n    When you want to own a value and you care only that it’s a type that implements a particular\n    trait rather than being of a specific type\n  </li>\n</ul>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">b</span> = Box::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b = {}\"</span>, b);\n}\n</code></pre>\n<p>\n  At compile time, Rust needs to know how much space a type takes up. One type whose size can’t be\n  known at compile time is a recursive type, where a value can have as part of itself another value\n  of the same type. Because this nesting of values could theoretically continue infinitely, Rust\n  doesn’t know how much space a value of a recursive type needs. However, boxes have a known size,\n  so by inserting a box in a recursive type definition, you can have recursive types.\n</p>\n<h2>Linked List</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-type\">i32</span>, <span class=\"hljs-type\">Box</span>&#x3C;List>),\n    Nil,\n}\n\n<span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">list</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">1</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">2</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">3</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(Nil))))));\n}\n</code></pre>\n<h2>Deref Trait</h2>\n<p>Implementing the <code>Deref</code> trait allows to customize the behavior of the dereference operator <code>*</code>.</p>\n<p>\n  A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a\n  value stored somewhere else.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">y</span> = &#x26;x;\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n}\n</code></pre>\n<p>\n  The variable <code>x</code> holds an <code>i32</code> value, <code>5</code>. We set <code>y</code> equal to a reference to <code>x</code>. We can assert\n  that <code>x</code> is equal to <code>5</code>. However, if we want to make an assertion about the value in <code>y</code>, we have\n  to use <code>*y</code> to follow the reference to the value it’s pointing to (hence dereference). Once we\n  dereference <code>y</code>, we have access to the integer value <code>y</code> is pointing to that we can compare with <code>5</code>.\n</p>\n<p>Comparing a number and a reference to a number isn’t allowed because they’re different types. We must use the dereference operator to follow the reference to the value it’s pointing to.</p>\n<p>It is possible to rewrite this code with <code>Box&#x3C;T></code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">y</span> = Box::<span class=\"hljs-title function_ invoke__\">new</span>(x);\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, x);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">5</span>, *y);\n}\n</code></pre>\n<h2>Custom Smart Pointers</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::ops::Deref;\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">MyBox</span>&#x3C;T>(T);\n\n<span class=\"hljs-keyword\">impl</span>&#x3C;T> MyBox&#x3C;T> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(x: T) <span class=\"hljs-punctuation\">-></span> MyBox&#x3C;T> {\n        <span class=\"hljs-title function_ invoke__\">MyBox</span>(x)\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&#x3C;T> Deref <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">MyBox</span>&#x3C;T> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Target</span> = T;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">deref</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> &#x26;<span class=\"hljs-keyword\">Self</span>::Target {\n        &#x26;<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\n    }\n}\n</code></pre>\n<p>\n  Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a plain dereference\n  so we don’t have to think about whether or not we need to call the deref method.\n</p>\n<p>\n  Deref coercion is a convenience that Rust performs on arguments to functions and methods.\n  Deref coercion works only on types that implement the Deref trait. Deref coercion converts such\n  a type into a reference to another type. For example, deref coercion can convert <code>&#x26;String</code> to <code>&#x26;str</code>\n  because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&#x26;str</code>. Deref coercion happens\n  automatically when we pass a reference to a particular type’s value as an argument to a function\n  or method that doesn’t match the parameter type in the function or method definition. A sequence\n  of calls to the deref method converts the type we provided into the type the parameter needs.\n</p>\n<p>Example of deref coercion:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">hello</span>(name: &#x26;<span class=\"hljs-type\">str</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Hello, {}!\"</span>, name);\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">m</span> = MyBox::<span class=\"hljs-title function_ invoke__\">new</span>(String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"Rust\"</span>));\n    <span class=\"hljs-title function_ invoke__\">hello</span>(&#x26;m);\n}\n</code></pre>\n<p>\n  Similar to immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator\n  on mutable references.\n</p>\n<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>\n<ul>\n  <li>From <code>&#x26;T</code> to <code>&#x26;U</code> when <code>T: Deref&#x3C;Target=U></code></li>\n  <li>From <code>&#x26;mut T</code> to <code>&#x26;mut U</code> when <code>T: DerefMut&#x3C;Target=U></code></li>\n  <li>From <code>&#x26;mut T</code> to <code>&#x26;U</code> when <code>T: Deref&#x3C;Target=U></code></li>\n</ul>\n<p>\n  The first two cases are the same except for mutability. The first case states that if you have a\n  <code>&#x26;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&#x26;U</code> transparently. The second\n  case states that the same deref coercion happens for mutable references.\n</p>\n<h2>Drop</h2>\n<p>\n  <code>Drop</code>, which lets you customize what happens when a value is about to go out of scope. You can\n  provide an implementation for the Drop trait on any type, and the code you specify can be used to\n  release resources like files or network connections. For example, when a <code>Box&#x3C;T></code> is dropped it\n  will deallocate the space on the heap that the box points to.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CustomSmartPointer</span> {\n    data: <span class=\"hljs-type\">String</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">CustomSmartPointer</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">drop</span>(&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Dropping CustomSmartPointer with data `{}`!\"</span>, <span class=\"hljs-keyword\">self</span>.data);\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">c</span> = CustomSmartPointer {\n        data: String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"my stuff\"</span>),\n    };\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">d</span> = CustomSmartPointer {\n        data: String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"other stuff\"</span>),\n    };\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"CustomSmartPointers created.\"</span>);\n}\n</code></pre>\n<p>this will print:</p>\n<pre><code class=\"hljs language-txt\">CustomSmartPointers created.\nDropping CustomSmartPointer with data `other stuff`!\nDropping CustomSmartPointer with data `my stuff`!\n</code></pre>\n<p>Variables are dropped in the reverse order of their creation, so <code>d</code> was dropped before <code>c</code>.</p>\n<h2>Reference Counted Smart Pointers</h2>\n<p>\n  <code>Rc&#x3C;T></code> - reference counted smart pointer allows to have multiple ownership on same entity.\n  The <code>Rc&#x3C;T></code> type keeps track of the number of references to a value to determine whether or not\n  the value is still in use. If there are zero references to a value, the value can be cleaned up\n  without any references becoming invalid.\n</p>\n<p>\n  <img src=\"images/smart_pointers_1.png\" alt=\"shared ownership\">\n</p>\n<p>Here <code>b</code> and <code>c</code> have references to <code>a</code>.</p>\n<p>This is highly useful in many use cases, for example in graphs and it's derivatives - trees, linked lists e.t.c.</p>\n<p><em><code>Rc&#x3C;T></code> is only for single threaded usecase</em></p>\n<p>Example of the problem:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-type\">i32</span>, <span class=\"hljs-type\">Box</span>&#x3C;List>),\n    Nil,\n}\n\n<span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">a</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">5</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">10</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(Nil))));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">b</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">3</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(a));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">c</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">4</span>, Box::<span class=\"hljs-title function_ invoke__\">new</span>(a));\n}\n</code></pre>\n<p>This code will not compile, because here multiple ownership of <code>a</code> occures, which is not allowed.</p>\n<p>Fix it with <code>Rc&#x3C;T></code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-type\">i32</span>, Rc&#x3C;List>),\n    Nil,\n}\n\n<span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n<span class=\"hljs-keyword\">use</span> std::rc::Rc;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">a</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">5</span>, Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">10</span>, Rc::<span class=\"hljs-title function_ invoke__\">new</span>(Nil)))));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">b</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">3</span>, Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;a));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">c</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">4</span>, Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;a));\n}\n</code></pre>\n<p>\n  Every time we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&#x3C;List></code> will\n  increase, and the data won’t be cleaned up unless there are zero references to it.\n</p>\n<p>\n  The call to <code>Rc::clone</code> only increments the reference count, which doesn’t take much time. Deep\n  copies of data can take a lot of time. By using <code>Rc::clone</code> for reference counting, we can visually\n  distinguish between the deep-copy kinds of clones and the kinds of clones that increase the\n  reference count.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">a</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">5</span>, Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">10</span>, Rc::<span class=\"hljs-title function_ invoke__\">new</span>(Nil)))));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"count after creating a = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">b</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">3</span>, Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;a));\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"count after creating b = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n    {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">c</span> = <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">4</span>, Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;a));\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"count after creating c = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"count after c goes out of scope = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n}\n</code></pre>\n<p>This will result in:</p>\n<pre><code class=\"hljs language-rust\">count after creating a = <span class=\"hljs-number\">1</span>\ncount after creating b = <span class=\"hljs-number\">2</span>\ncount after creating c = <span class=\"hljs-number\">3</span>\ncount after c goes out of scope = <span class=\"hljs-number\">2</span>\n</code></pre>\n<p><strong>Dereferencing <code>Rc&#x3C;T></code>:</strong></p>\n<p>\n  To dereference <code>Rc&#x3C;T></code> used operator <code>*</code>, but it is also can be done implicitly. So it\n  is possible to do:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-string\">\"value\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n<span class=\"hljs-built_in\">print!</span>(<span class=\"hljs-string\">\"let: {}\"</span>, x.<span class=\"hljs-title function_ invoke__\">len</span>());\n</code></pre>\n<p><strong>Moving value from <code>Rc&#x3C;T></code>:</strong></p>\n<p>\n  Sometimes it is useful to move ownership on the underlying value from <code>Rc</code> to somewhere else.\n  It may be done with <code>Rc::try_unwrap(rc_pointer)</code>. But there is a complexity - such move may\n  be done only in case, when there is only one strong reference exists in this <code>Rc</code>. In other\n  case <code>try_unwrap</code> will return an error.\n</p>\n<h2>Interior Mutability And <code>RefCell</code></h2>\n<h2>Memory Leaks</h2>\n<p>\n  It is possible to create memory leak in <code>Rust</code> with <code>Rc&#x3C;T></code> or <code>RefCell&#x3C;T></code> by creating cycle\n  references. Such a way that one object may reference itself and always having active references\n  it will not be cleaned.\n</p>\n<p>For example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> crate::List::{Cons, Nil};\n<span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n<span class=\"hljs-keyword\">use</span> std::rc::Rc;\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-type\">i32</span>, RefCell&#x3C;Rc&#x3C;List>>),\n    Nil,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tail</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Option</span>&#x3C;&#x26;RefCell&#x3C;Rc&#x3C;List>>> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            <span class=\"hljs-title function_ invoke__\">Cons</span>(_, item) => <span class=\"hljs-title function_ invoke__\">Some</span>(item),\n            Nil => <span class=\"hljs-literal\">None</span>,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">a</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">5</span>, RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(Rc::<span class=\"hljs-title function_ invoke__\">new</span>(Nil))));\n\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a initial rc count = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a next item = {:?}\"</span>, a.<span class=\"hljs-title function_ invoke__\">tail</span>());\n\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">b</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Cons</span>(<span class=\"hljs-number\">10</span>, RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;a))));\n\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a rc count after b creation = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b initial rc count = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;b));\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b next item = {:?}\"</span>, b.<span class=\"hljs-title function_ invoke__\">tail</span>());\n\n  <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Some</span>(link) = a.<span class=\"hljs-title function_ invoke__\">tail</span>() {\n      *link.<span class=\"hljs-title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;b);\n  }\n\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"b rc count after changing a = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;b));\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"a rc count after changing a = {}\"</span>, Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;a));\n\n  <span class=\"hljs-comment\">// Uncomment the next line to see that we have a cycle;</span>\n  <span class=\"hljs-comment\">// it will overflow the stack</span>\n  <span class=\"hljs-comment\">// println!(\"a next item = {:?}\", a.tail());</span>\n}\n</code></pre>\n<h2>Preventing Reference Cycles</h2>\n<p>So far, we’ve demonstrated that calling Rc::clone increases the strong_count of an Rc instance, and an Rc instance is only cleaned up if its strong_count is 0. You can also create a weak reference to the value within an Rc instance by calling Rc::downgrade and passing a reference to the Rc. When you call Rc::downgrade, you get a smart pointer of type Weak. Instead of increasing the strong_count in the Rc instance by 1, calling Rc::downgrade increases the weak_count by 1. The Rc type uses weak_count to keep track of how many Weak references exist, similar to strong_count. The difference is the weak_count doesn’t need to be 0 for the Rc instance to be cleaned up.</p>\n<p>Strong references are how you can share ownership of an Rc istance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>\n<p>Because the value that Weak references might have been dropped, to do anything with the value that a Weak is pointing to, you must make sure the value still exists. Do this by calling the upgrade method on a Weak instance, which will return an Option&#x3C;Rc>. You’ll get a result of Some if the Rc value has not been dropped yet and a result of None if the Rc value has been dropped. Because upgrade returns an Option&#x3C;Rc>, Rust will ensure that the Some case and the None case are handled, and there won’t be an invalid pointer.</p>\n<p>As an example, rather than using a list whose items know only about the next item, we’ll create a tree whose items know about their children items and their parent items.</p>\n<h2>Tree</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::cell::RefCell;\n<span class=\"hljs-keyword\">use</span> std::rc::{Rc, Weak};\n\n<span class=\"hljs-meta\">#[derive(Debug)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n    value: <span class=\"hljs-type\">i32</span>,\n    parent: RefCell&#x3C;Weak&#x3C;Node>>,\n    children: RefCell&#x3C;<span class=\"hljs-type\">Vec</span>&#x3C;Rc&#x3C;Node>>>,\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">leaf</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(Node {\n        value: <span class=\"hljs-number\">3</span>,\n        parent: RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(Weak::<span class=\"hljs-title function_ invoke__\">new</span>()),\n        children: RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-built_in\">vec!</span>[]),\n    });\n\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n        Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;leaf),\n        Rc::<span class=\"hljs-title function_ invoke__\">weak_count</span>(&#x26;leaf),\n    );\n\n    {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">branch</span> = Rc::<span class=\"hljs-title function_ invoke__\">new</span>(Node {\n            value: <span class=\"hljs-number\">5</span>,\n            parent: RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(Weak::<span class=\"hljs-title function_ invoke__\">new</span>()),\n            children: RefCell::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-built_in\">vec!</span>[Rc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;leaf)]),\n        });\n\n        *leaf.parent.<span class=\"hljs-title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"hljs-title function_ invoke__\">downgrade</span>(&#x26;branch);\n\n        <span class=\"hljs-built_in\">println!</span>(\n            <span class=\"hljs-string\">\"branch strong = {}, weak = {}\"</span>,\n            Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;branch),\n            Rc::<span class=\"hljs-title function_ invoke__\">weak_count</span>(&#x26;branch),\n        );\n\n        <span class=\"hljs-built_in\">println!</span>(\n            <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n            Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;leaf),\n            Rc::<span class=\"hljs-title function_ invoke__\">weak_count</span>(&#x26;leaf),\n        );\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"leaf parent = {:?}\"</span>, leaf.parent.<span class=\"hljs-title function_ invoke__\">borrow</span>().<span class=\"hljs-title function_ invoke__\">upgrade</span>());\n    <span class=\"hljs-built_in\">println!</span>(\n        <span class=\"hljs-string\">\"leaf strong = {}, weak = {}\"</span>,\n        Rc::<span class=\"hljs-title function_ invoke__\">strong_count</span>(&#x26;leaf),\n        Rc::<span class=\"hljs-title function_ invoke__\">weak_count</span>(&#x26;leaf),\n    );\n}\n</code></pre>\n<h2>References</h2>\n<p>\n  <a href=\"https://doc.rust-lang.org/stable/book/ch15-06-reference-cycles.html\">Reference Cycles</a>\n  <a href=\"https://doc.rust-lang.org/stable/book/ch15-01-box.html\">Using Box to Point to Data on the Heap</a>\n</p>\n"}},"__N_SSG":true}