{"pageProps":{"noteKey":["rust","pattern-matching"],"note":{"title":"Rust - Pattern Matching","date":"2022-03-11","content":"\n<p>\n  Pattern matching in Rust implemented with <code>match</code> statement, which contains list of pattern to\n  expression pairs called <code>arms</code>.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">match</span> VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n</code></pre>\n<p>\n  <code>match</code> arms must contain all possible variants of execution. There will be a compilation error\n  if there is some case of exectution which not specified as a <code>match</code> arm.\n</p>\n<p>\n  One solution to use <code>_</code> pattern, which allows to gather all possible variants, not specified\n  directly.\n</p>\n<h2>if let</h2>\n<p>Another solution for situations when we need to catch only one pattern case is to use <code>if let</code> construct.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">favorite_color</span>: <span class=\"hljs-type\">Option</span>&#x3C;&#x26;<span class=\"hljs-type\">str</span>> = <span class=\"hljs-literal\">None</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">is_tuesday</span> = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">age</span>: <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">u8</span>, _> = <span class=\"hljs-string\">\"34\"</span>.<span class=\"hljs-title function_ invoke__\">parse</span>();\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Some</span>(color) = favorite_color {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Using your favorite color, {}, as the background\"</span>, color);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> is_tuesday {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Tuesday is green day!\"</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Ok</span>(age) = age {\n        <span class=\"hljs-keyword\">if</span> age > <span class=\"hljs-number\">30</span> {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Using purple as the background color\"</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Using orange as the background color\"</span>);\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Using blue as the background color\"</span>);\n    }\n}\n</code></pre>\n<p>\n  Here important to notice, that <code>let if</code> as well as <code>match</code> can create shadowing varable, like in\n  line <code>} else if let Ok(age) = age {</code>. This means that further <code>if age > 30</code> has the value from <code>Ok(age)</code>\n  and not original <code>age</code>. And also this means that it is not possible to use age this way:\n  <code>} else if let Ok(age) = age &#x26;&#x26; age > 30{</code>.\n</p>\n<h2>while let</h2>\n<p>This expression is sililar to <code>if let</code>, but here <code>while</code> loop will run until pattern is matching.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">stack</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n\nstack.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">1</span>);\nstack.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">2</span>);\nstack.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Some</span>(top) = stack.<span class=\"hljs-title function_ invoke__\">pop</span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, top);\n}\n</code></pre>\n<h2>for</h2>\n<p>\n  <code>for</code> loop in Rust also uses pattern matching. In particular, expression, following <code>for</code> keyword\n  is a pattern.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">v</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>];\n\n<span class=\"hljs-title function_ invoke__\">for</span> (index, value) <span class=\"hljs-keyword\">in</span> v.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">enumerate</span>() {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{} is at index {}\"</span>, value, index);\n}\n</code></pre>\n<h2>let</h2>\n<p>\n  Assignment in Rust is also a pattern. For example: <code>let x = 5;</code> is <code>let PATTERN = EXPRESSION;</code>.\n  Example, <code>x</code> is a pattern that means “bind what matches here to the variable x.” Because the name\n  <code>x</code> is the whole pattern, this pattern effectively means “bind everything to the variable <code>x</code>,\n  whatever the value is.”\n</p>\n<p>More complex example of it:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> (x, y, z) = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n</code></pre>\n<p>Functional parameters also may be patterns:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">print_coordinates</span>(&#x26;(x, y): &#x26;(<span class=\"hljs-type\">i32</span>, <span class=\"hljs-type\">i32</span>)) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Current location: ({}, {})\"</span>, x, y);\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">point</span> = (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-title function_ invoke__\">print_coordinates</span>(&#x26;point);\n}\n</code></pre>\n<p><strong>Matching literals:</strong></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">1</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one\"</span>),\n    <span class=\"hljs-number\">2</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"two\"</span>),\n    <span class=\"hljs-number\">3</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"three\"</span>),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"anything\"</span>),\n}\n</code></pre>\n<p><strong>Matching Named Variables:</strong></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">y</span> = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">50</span>) => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got 50\"</span>),\n    <span class=\"hljs-title function_ invoke__\">Some</span>(y) => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched, y = {:?}\"</span>, y),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Default case, x = {:?}\"</span>, x),\n}\n\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"at the end: x = {:?}, y = {:?}\"</span>, x, y);\n</code></pre>\n<p><strong>Matching Multiple Patterns:</strong></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">match</span> {\n    <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one or two\"</span>),\n    <span class=\"hljs-number\">3</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"three\"</span>),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"anything\"</span>),\n}\n</code></pre>\n<p><strong>Matching Ranges:</strong></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">1</span>..=<span class=\"hljs-number\">5</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"one through five\"</span>),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"something else\"</span>),\n}\n</code></pre>\n<p>\n  Ranges are only allowed with numeric values or char values, because the compiler checks that the\n  range isn’t empty at compile time.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-string\">'c'</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-string\">'a'</span>..=<span class=\"hljs-string\">'j'</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"early ASCII letter\"</span>),\n    <span class=\"hljs-string\">'k'</span>..=<span class=\"hljs-string\">'z'</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"late ASCII letter\"</span>),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"something else\"</span>),\n}\n</code></pre>\n<h2>Conditional Pattern Matching</h2>\n<p><code>match</code> also supprts additional conditions:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">num</span> = <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">4</span>);\n\n<span class=\"hljs-keyword\">match</span> num {\n    <span class=\"hljs-title function_ invoke__\">Some</span>(x) <span class=\"hljs-keyword\">if</span> x &#x3C; <span class=\"hljs-number\">5</span> => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"less than five: {}\"</span>, x),\n    <span class=\"hljs-title function_ invoke__\">Some</span>(x) => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x),\n    <span class=\"hljs-literal\">None</span> => (),\n}\n</code></pre>\n<p>\n  Extra condition also solves shadowing problem, when <code>match</code> creates new variable with same name\n  which can hide external scope variable:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">y</span> = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">match</span> x {\n        <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">50</span>) => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got 50\"</span>),\n        <span class=\"hljs-title function_ invoke__\">Some</span>(n) <span class=\"hljs-keyword\">if</span> n == y => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Matched, n = {}\"</span>, n),\n        _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Default case, x = {:?}\"</span>, x),\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"at the end: x = {:?}, y = {}\"</span>, x, y);\n}\n</code></pre>\n<p>With <code>|</code> operator:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">4</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">y</span> = <span class=\"hljs-literal\">false</span>;\n\n<span class=\"hljs-keyword\">match</span> x {\n    <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span> | <span class=\"hljs-number\">6</span> <span class=\"hljs-keyword\">if</span> y => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"yes\"</span>),\n    _ => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"no\"</span>),\n}\n</code></pre>\n<h2>@ operator</h2>\n<p><code>@</code> allows to create new variable and test it on some pattern, but use it after in matched block:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Message</span> {\n    Hello { id: <span class=\"hljs-type\">i32</span> },\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">msg</span> = Message::Hello { id: <span class=\"hljs-number\">5</span> };\n\n<span class=\"hljs-keyword\">match</span> msg {\n    Message::Hello {\n        id: id_variable @ <span class=\"hljs-number\">3</span>..=<span class=\"hljs-number\">7</span>,\n    } => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found an id in range: {}\"</span>, id_variable),\n    Message::Hello { id: <span class=\"hljs-number\">10</span>..=<span class=\"hljs-number\">12</span> } => {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found an id in another range\"</span>)\n    }\n    Message::Hello { id } => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Found some other id: {}\"</span>, id),\n}\n</code></pre>\n<h2>References</h2>\n<ul>\n  <li><a href=\"https://doc.rust-lang.org/stable/book/ch18-01-all-the-places-for-patterns.html\">Rust Book - Pattern Matching</a></li>\n</ul>\n"}},"__N_SSG":true}