{"pageProps":{"noteKey":["rust","closures_and_capturing"],"note":{"title":"Closures And Capturing","date":"2022-10-17","content":"\n<p><code>Closure</code> in Rust is a function which is able to capture vairable from context, which is global to it.</p>\n<p>For example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">const</span> x: <span class=\"hljs-type\">u8</span> = <span class=\"hljs-number\">10u8</span>;\n<span class=\"hljs-keyword\">const</span> closure: <span class=\"hljs-title function_ invoke__\">fn</span>(<span class=\"hljs-type\">u8</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u8</span> = |y: <span class=\"hljs-type\">u8</span>| <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u8</span> x * y;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">func</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u8</span> {\n    <span class=\"hljs-title function_ invoke__\">closure</span>(<span class=\"hljs-number\">5u8</span>)\n}\n</code></pre>\n<p>It is allowed in Rust to not put type annotations in closure definition. This way types will be infered from the context.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">closure</span> = |y| x * y;\n</code></pre>\n<p>\n  By default Rust compiler takes least possible ownership on enclosed variables. To force closure to take ownership on\n  enclosed scope you can use <code>move</code> keyword:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">with_moving_ownership</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5u8</span>;\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">closure</span> = <span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}\"</span>, x)\n    }\n\n    <span class=\"hljs-comment\">// here x is not available</span>\n}\n</code></pre>\n<h2>Passing Closure As A Parameter</h2>\n<p>\n  But when passing a reference to the closure, definition of it's signature is mandatory. To desribe closure there are exist\n  several traits:\n</p>\n<ul>\n  <li><code>Fn</code> - this means, that captured values will be reference with <code>&#x26;</code></li>\n  <li><code>FnOnce</code> - closure takes full ownership on the captured values</li>\n  <li><code>FnMut</code> - closure has mutable reference on the captures values with <code>&#x26;mut</code></li>\n</ul>\n<p>\n  But these traits define a maximum restriction possible for access to closed scope. But it does not mean that this borrowing\n  will actually happen. If compiler will see that it can use less restrictive borrowing rule it will use it.\n</p>\n<p>Any regular function, which satisfies to the required function trait may be passed as a parameter instead of closure.</p>\n<h2>Returning A Closure From Function</h2>\n<p>\n  It is possible to return closure from function. But it is associated with additional restrictions. Returned closure must\n  own all it's enclosed variables. To do this, use <code>move</code> keyword. Also we have to use <code>impl</code> keyword for returned closure type, e.g:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">create_sum</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Fn</span>(<span class=\"hljs-type\">u8</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u8</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x1</span> = <span class=\"hljs-number\">5u8</span>;\n\n    <span class=\"hljs-keyword\">move</span> |y| y + x1\n}\n</code></pre>\n<p>Or return pointer to function:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">create_sum_box</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-title function_ invoke__\">Fn</span>(<span class=\"hljs-type\">u8</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">u8</span>> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x1</span> = <span class=\"hljs-number\">5u8</span>;\n\n    Box::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-keyword\">move</span> |y| y * x1)\n}\n</code></pre>\n"}},"__N_SSG":true}