{"pageProps":{"noteKey":["rust","concurrency"],"note":{"title":"Rust Concurrency","date":"2022-03-05","content":"\n<p>Modern operating systems manage programms execution with <code>processes</code>.</p>\n<p><code>Process</code> - is a basic unit of work to be implemented in a operatin system.</p>\n<p>\n  The OS takes a program as a set of instructions and run all it's instructions in context of some\n  process. Each process has it's own <code>stack</code> and <code>heap</code>.\n</p>\n<p>Within one <code>process</code> program can run multiple threads.</p>\n<p><code>Thread</code> - is a smallest sequence of instructions, that can be managed independently by OS scheduler.</p>\n<p>Multiple thread of one process share this process's heap.</p>\n<p>Multithreaded execution may have several problems:</p>\n<ul>\n  <li><code>Race conditions</code>, where threads are accessing data or resources in an inconsistent order</li>\n  <li>\n    <code>Deadlocks</code>, where two threads are waiting for each other to finish using a resource the other\n    thread has, preventing both threads from continuing\n  </li>\n  <li>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</li>\n</ul>\n<p>\n  Usually OS gives an public interface to create new threads. Usin it called <code>1:1</code> - one program\n  thread for one OS thread. Some languages have their own implementation of threads, where it is not\n  necessary one to one relationship between language and OS threads amount. Such threads called\n  <code>grean threads</code>. It is <code>M:N</code> model, where <code>M</code> is amount of green threads and <code>N</code> is an amount of\n  OS threads.\n</p>\n<p>Rust standard library provides only <code>1:1</code> model in order to have smaller runtime.</p>\n<h2>Creating Threads</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::thread;\n<span class=\"hljs-keyword\">use</span> std::time::Duration;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(|| {\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">10</span> {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"hi number {} from the spawned thread!\"</span>, i);\n            thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_millis</span>(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">5</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"hi number {} from the main thread!\"</span>, i);\n        thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_millis</span>(<span class=\"hljs-number\">1</span>));\n    }\n}\n</code></pre>\n<p><em>all started threads will be eventually stopped or when they will execute all their instructions or when main thread will be stopped</em></p>\n<p>To ensure all threads finished correctly, use <code>join</code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::thread;\n<span class=\"hljs-keyword\">use</span> std::time::Duration;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">handle</span> = thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(|| {\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">10</span> {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"hi number {} from the spawned thread!\"</span>, i);\n            thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_millis</span>(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">5</span> {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"hi number {} from the main thread!\"</span>, i);\n        thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_millis</span>(<span class=\"hljs-number\">1</span>));\n    }\n\n    handle.<span class=\"hljs-title function_ invoke__\">join</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n}\n</code></pre>\n<p>Calling <code>handle.join()</code> blocks main thread's execution until this <code>handle</code> thread will be finished.</p>\n<h3>Outer Context</h3>\n<p>Rust can not infer, how long thread will live, so following will not work:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">v</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">handle</span> = thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(|| {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Here's a vector: {:?}\"</span>, v);\n    });\n\n    <span class=\"hljs-title function_ invoke__\">drop</span>(v); <span class=\"hljs-comment\">// oh no!</span>\n\n    handle.<span class=\"hljs-title function_ invoke__\">join</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n}\n</code></pre>\n<p>This can be solved my moving ownership to the thread context with <code>move</code> closure:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">v</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">handle</span> = thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Here's a vector: {:?}\"</span>, v);\n    });\n\n    handle.<span class=\"hljs-title function_ invoke__\">join</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n}\n</code></pre>\n<p>\n  But in this case after thread has started, we don't have access to <code>v</code> vector, because it has\n  already been moved.\n</p>\n<h2>Synchronization</h2>\n<h3>Message Passing</h3>\n<p>\n  <code>Message passing</code> - threads or actors communicate by sending each other messages containing data.\n  As an implementation of this concept Rust uses <code>channels</code>.\n</p>\n<p>Channel consists of two parts:</p>\n<ul>\n  <li><code>transmitter</code> - is an upstream where source data is sent.</li>\n  <li><code>receiver</code> - is a target location of data.</li>\n</ul>\n<p>Channel is closing when closing either <code>transmitter</code> or <code>receiver</code>.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::<span class=\"hljs-title function_ invoke__\">channel</span>();\n\n    thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">val</span> = String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"hi\"</span>);\n        tx.<span class=\"hljs-title function_ invoke__\">send</span>(val).<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n    });\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">received</span> = rx.<span class=\"hljs-title function_ invoke__\">recv</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {}\"</span>, received);\n}\n</code></pre>\n<p>\n  <code>mpsc</code> stands for multiple producer, single consumer. Channel can have multiple sending ends that\n  produce values but only one receiving end that consumes those values. The <code>mpsc::channel</code> function\n  returns a tuple, the first element of which is the sending end and the second element is the\n  receiving end. The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in many fields for\n  transmitter and receiver respectively, so we name our variables as such to indicate each end.\n</p>\n<p>\n  We move transmitter to the new thread and send a value into it from this thread. The spawned thread\n  needs to own the transmitting end of the channel to be able to send messages through the channel.\n  The send method returns a <code>Result&#x3C;T, E></code> type, so if the receiving end has already been dropped\n  and there’s nowhere to send a value, the send operation will return an error.\n</p>\n<p>Then we are able to receive sent value in the main thread with receiver instance.</p>\n<p>Send moves ownership of sent variables so it is not possible to use them after that in this thread.</p>\n<p>\n  <code>recv</code>, short for receive, which will block the main thread’s execution and wait until a value is\n  sent down the channel. Once a value is sent, recv will return it in a <code>Result&#x3C;T, E></code>. When the\n  sending end of the channel closes, recv will return an error to signal that no more values will be\n  coming.\n</p>\n<p>\n  The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&#x3C;T, E></code> immediately: an <code>Ok</code>\n  value holding a message if one is available and an <code>Err</code> value if there aren’t any messages this\n  time. Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages:\n  we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available,\n  and otherwise does other work for a little while until checking again.\n</p>\n<h3>Multiple Producers</h3>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::sync::mpsc;\n<span class=\"hljs-keyword\">use</span> std::thread;\n<span class=\"hljs-keyword\">use</span> std::time::Duration;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> (tx, rx) = mpsc::<span class=\"hljs-title function_ invoke__\">channel</span>();\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">tx1</span> = tx.<span class=\"hljs-title function_ invoke__\">clone</span>();\n    thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">vals</span> = <span class=\"hljs-built_in\">vec!</span>[\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"hi\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"from\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"the\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"thread\"</span>),\n        ];\n\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">val</span> <span class=\"hljs-keyword\">in</span> vals {\n            tx1.<span class=\"hljs-title function_ invoke__\">send</span>(val).<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n            thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_secs</span>(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">vals</span> = <span class=\"hljs-built_in\">vec!</span>[\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"more\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"messages\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"for\"</span>),\n            String::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">\"you\"</span>),\n        ];\n\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">val</span> <span class=\"hljs-keyword\">in</span> vals {\n            tx.<span class=\"hljs-title function_ invoke__\">send</span>(val).<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n            thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_secs</span>(<span class=\"hljs-number\">1</span>));\n        }\n    });\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">received</span> <span class=\"hljs-keyword\">in</span> rx {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Got: {}\"</span>, received);\n    }\n}\n</code></pre>\n<h2>Mutexes</h2>\n<p>\n  <code>Mutex</code> is an abbreviation for mutual exclusion, as in, a mutex allows only one thread to access\n  some data at any given time. To access the data in a mutex, a thread must first signal that it\n  wants access by asking to acquire the mutex’s lock. The lock is a data structure that is part of\n  the mutex that keeps track of who currently has exclusive access to the data. Therefore, the mutex\n  is described as guarding the data it holds via the locking system.\n</p>\n<p>There are two basic steps to use <code>mutex</code>:</p>\n<ol>\n  <li>Engage lock with mutex before accessing actual data</li>\n  <li>Release lock from mutex to allow other threads to use it</li>\n</ol>\n<p>\n  <strong>Mutex</strong> - is a smart pointer allowing to access inner data concurrently. To use inner value\n  we have to call <code>lock</code> method on it. It will block the thread and return a <code>LockResult</code>. If the\n  value is locked by another thread it will wait for release. If another thread, which locked\n  resource before current <code>lock</code> call paniced, <code>LockResult</code> will return error. Success case is\n  <code>MutexGuard</code>, which points to actual data. It implements <code>Deref</code> and <code>Drop</code> traits, so it will\n  automatically release the locked value after <code>MutexGuard</code> will go out of scope.\n</p>\n<p>Let's see, how to use mutex in Rust on example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::sync::Mutex;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">m</span> = Mutex::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">5</span>);\n\n    {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">num</span> = m.<span class=\"hljs-title function_ invoke__\">lock</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n        *num = <span class=\"hljs-number\">6</span>;\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"m = {:?}\"</span>, m);\n}\n</code></pre>\n<p><strong>Sharing mutexes between threads:</strong></p>\n<p>\n  <code>Mutex&#x3C;T></code> can not be easily shared between threads because of ownership rules ensuring, that\n  there is only a single owner of the variable may exist at one moment of time. So we have to use\n  wrapping to another smart pointer. We may try to use <code>Rc&#x3C;T></code> smart pointer, but although it\n  can solve the problem partially, it is not intended to use in multithreaded context. But there is\n  a similar concpet - <code>std::sync::atomic::Arc&#x3C;T></code>, which does the same, <code>Rc&#x3C;T></code> can, but with\n  guarantees for thread safety.\n</p>\n<p>\n  The reason, why functionality of <code>Arc&#x3C;T></code> does not embedded into regular <code>Rc&#x3C;T></code> is little\n  performance downgrade as a price for thread safety. So if we don't require synchronization,\n  we normally don't need this guarantees.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> std::sync::{Arc, Mutex};\n<span class=\"hljs-keyword\">use</span> std::thread;\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">counter</span> = Arc::<span class=\"hljs-title function_ invoke__\">new</span>(Mutex::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">0</span>));\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">handles</span> = <span class=\"hljs-built_in\">vec!</span>[];\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">counter</span> = Arc::<span class=\"hljs-title function_ invoke__\">clone</span>(&#x26;counter);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">handle</span> = thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">num</span> = counter.<span class=\"hljs-title function_ invoke__\">lock</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n\n            *num += <span class=\"hljs-number\">1</span>;\n        });\n        handles.<span class=\"hljs-title function_ invoke__\">push</span>(handle);\n    }\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">handle</span> <span class=\"hljs-keyword\">in</span> handles {\n        handle.<span class=\"hljs-title function_ invoke__\">join</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n    }\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Result: {}\"</span>, *counter.<span class=\"hljs-title function_ invoke__\">lock</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>());\n}\n</code></pre>\n<h2>Send</h2>\n<p>\n  To be able to send objects and their ownership between threads, these objects have to implement\n  <code>Sync</code> trait. By default almost all Rust objects implements it. But there are some exceptions, like\n  <code>Rc&#x3C;T></code>, which is not thread safe.\n</p>\n<h2>Sync</h2>\n<p><code>Sync</code> is a trait, which shows that type, implementing <code>Send</code> may be safely referenced by many threads.</p>\n<p>\n  Complex types, which consist of other <code>Send</code> + <code>Sync</code> compatible objects are automatically also\n  implement <code>Send+Sync</code>.\n</p>\n<h2>References</h2>\n<ul>\n  <li><a href=\"https://doc.rust-lang.org/stable/book/ch16-01-threads.html\">Using Threads to Run Code Simultaneously</a></li>\n  <li><a href=\"https://www.tutorialspoint.com/operating_system/os_processes.html\">Operating System - Processes</a></li>\n  <li><a href=\"https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html\">Using Message Passing to Transfer Data Between Threads</a></li>\n</ul>\n"}},"__N_SSG":true}