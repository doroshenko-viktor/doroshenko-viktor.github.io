{"pageProps":{"noteKey":["rust","useful-traits"],"note":{"title":"Rust Useful Traits","date":"2022-04-04","content":"\n<ul>\n  <li><a href=\"#comparison\">Comparison</a>\n    <ul>\n      <li><a href=\"#stdcmppartialeq\">std::cmp::PartialEq</a></li>\n      <li><a href=\"#stdcmppartialord\">std::cmp::PartialOrd</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#lifecycle\">Lifecycle</a>\n    <ul>\n      <li><a href=\"#stdopsdrop\">std::ops::Drop</a></li>\n      <li><a href=\"#stdopsderef\">std::ops::Deref</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#operators\">Operators</a>\n    <ul>\n      <li><a href=\"#stdopsindex\">std::ops::Index</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#async\">Async</a>\n    <ul>\n      <li><a href=\"#stdfuturefuture\">std::future::Future</a></li>\n    </ul>\n  </li>\n</ul>\n<h2>Comparison</h2>\n<h3>std::cmp::PartialEq</h3>\n<p><a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#\">Full Doc</a></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">PartialEq</span>&#x3C;Rhs = <span class=\"hljs-keyword\">Self</span>>\n<span class=\"hljs-keyword\">where</span> Rhs: ?<span class=\"hljs-built_in\">Sized</span>,\n{\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">eq</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span>;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">ne</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> { ... }\n}\n</code></pre>\n<p>Trait for equality comparisons which are partial equivalence relations.</p>\n<p><code>x.eq(y)</code> can also be written <code>x == y</code>, and <code>x.ne(y)</code> can be written <code>x != y</code>.</p>\n<p>Implementations must ensure that <code>eq</code> and <code>ne</code> are consistent with each other.</p>\n<p>This trait can be used with <code>#[derive]</code>. When derived on <code>structs</code>, two instances are equal if all fields are equal, and not equal if any fields are not equal. When derived on <code>enums</code>, each variant is equal to itself and not equal to the other variants.</p>\n<h3>std::cmp::PartialOrd</h3>\n<p><a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\">Full Doc</a></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">PartialOrd</span>&#x3C;Rhs = <span class=\"hljs-keyword\">Self</span>>: <span class=\"hljs-built_in\">PartialEq</span>&#x3C;Rhs>\n<span class=\"hljs-keyword\">where</span> Rhs: ?<span class=\"hljs-built_in\">Sized</span>,\n{\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">partial_cmp</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Option</span>&#x3C;Ordering>;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">lt</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> { ... }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">le</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> { ... }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">gt</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> { ... }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">ge</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;Rhs) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> { ... }\n}\n</code></pre>\n<p>Trait for values that can be compared for a sort-order.</p>\n<p>The <code>lt</code>, <code>le</code>, <code>gt</code>, and ge methods of this trait can be called using the <code>&#x3C;</code>, <code>&#x3C;=</code>, <code>></code>, and <code>>=</code> operators, respectively.</p>\n<p>The methods of this trait must be consistent with each other and with those of <code>PartialEq</code> in the following sense:</p>\n<p>\n  <code>a == b</code> if and only if <code>partial_cmp(a, b) == Some(Equal)</code>.\n  <code>a &#x3C; b</code> if and only if <code>partial_cmp(a, b) == Some(Less)</code> (ensured by the default implementation).\n  <code>a > b</code> if and only if partial_cmp(a, b) == Some(Greater) (ensured by the default implementation).\n  <code>a &#x3C;= b</code> if and only if <code>a &#x3C; b || a == b</code> (ensured by the default implementation).\n  <code>a >= b </code>if and only if <code>a > b || a == b </code>(ensured by the default implementation).\n  <code>a != b</code> if and only if <code>!(a == b)</code> (already part of PartialEq).\n</p>\n<h2>Lifecycle</h2>\n<h3>std::ops::Drop</h3>\n<p><a href=\"https://doc.rust-lang.org/std/ops/trait.Drop.html\">Full Doc</a></p>\n<p>Represents deconstructor for object, which will be called, when object is deleting.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">HasDrop</span>;\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Drop</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">HasDrop</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">drop</span>(&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"Dropping HasDrop!\"</span>);\n    }\n}\n</code></pre>\n<p>e.g. <code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> implement the <code>Drop</code> trait to free resources.</p>\n<h3>std::ops::Deref</h3>\n<p><a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\">Full Doc</a></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Deref</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Target</span>: ?<span class=\"hljs-built_in\">Sized</span>;\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">deref</span>(&#x26;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> &#x26;<span class=\"hljs-keyword\">Self</span>::Target;\n}\n</code></pre>\n<p>Used for immutable dereferencing operations, like <code>*v</code>. <code>Deref</code> also used implicitly by the compiler in many circumstances. This mechanism is called <code>Deref coercion</code>. In mutable contexts, <code>DerefMut</code> is used.</p>\n<p><code>Deref</code> should only be implemented for smart pointers to avoid confusion. This trait should never fail. Failure during dereferencing can be extremely confusing when <code>Deref</code> is invoked implicitly.</p>\n<h2>Operators</h2>\n<h3>std::ops::Index</h3>\n<p><a href=\"https://doc.rust-lang.org/std/ops/trait.Index.html\">Doc</a></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Index</span>&#x3C;Idx> \n<span class=\"hljs-keyword\">where</span>\n    Idx: ?<span class=\"hljs-built_in\">Sized</span>, \n{\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Output</span>: ?<span class=\"hljs-built_in\">Sized</span>;\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">index</span>(&#x26;<span class=\"hljs-keyword\">self</span>, index: Idx) <span class=\"hljs-punctuation\">-></span> &#x26;<span class=\"hljs-keyword\">Self</span>::Output;\n}\n</code></pre>\n<p>Used for indexing operations <code>(</code>container[index]<code>)</code> in immutable contexts.</p>\n<p><code>container[index]</code> is actually syntactic sugar for <code>*container.index(index)</code>, but only when used as an immutable value. If a mutable value is requested, <code>IndexMut</code> is used instead. This allows nice things such as <code>let value = v[index]</code> if the type of value implements <code>Copy</code>.</p>\n<h2>Async</h2>\n<h3>std::future::Future</h3>\n<p><a href=\"https://doc.rust-lang.org/std/future/trait.Future.html\">Full Doc</a></p>\n"}},"__N_SSG":true}