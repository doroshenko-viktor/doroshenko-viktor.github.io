{"pageProps":{"noteKey":["algorithms","bfs"],"note":{"title":"Breadth-First Search","date":"2025-10-03","content":"\n<h2>Breadth-First Search (BFS) on Trees</h2>\n<p>Breadth-First Search (BFS) is a fundamental algorithm used to traverse or search through tree and graph data structures. In trees, <code>BFS</code> explores nodes level by level, starting from the root and moving down to each subsequent level. This makes it ideal for scenarios where we want to process nodes in order of their depth.</p>\n<hr>\n<h2>Why BFS is Needed</h2>\n<p>BFS is particularly useful in situations such as:</p>\n<ul>\n  <li><strong>Finding the shortest path</strong> in an unweighted tree or graph.</li>\n  <li><strong>Level-order traversal</strong> of a tree.</li>\n  <li><strong>Checking connectivity</strong> or presence of a node.</li>\n  <li><strong>Solving problems</strong> where we need information from nodes closest to the root first.</li>\n</ul>\n<p>Unlike <code>Depth-First Search (DFS)</code>, which goes deep into one branch before exploring others, <code>BFS</code> guarantees that we process all nodes at depth<code>d</code>before moving to depth<code>d+1</code>.</p>\n<hr>\n<h2>How BFS Works</h2>\n<ol>\n  <li><strong>Start at the root node.</strong></li>\n  <li><strong>Initialize a queue</strong> and enqueue the root node.</li>\n  <li><strong>While the queue is not empty</strong>:\n    <ul>\n      <li>Dequeue the front node.</li>\n      <li>Process the node (e.g., print its value).</li>\n      <li>Enqueue all of its children.</li>\n    </ul>\n  </li>\n  <li><strong>Repeat</strong> until all nodes are processed.</li>\n</ol>\n<p>The key idea is using a <strong>queue</strong> to maintain the order of nodes to be processed.</p>\n<hr>\n<h2>Python Implementation</h2>\n<p>Here’s a simple implementation of BFS for a binary tree:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TreeNode</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, val</span>):\n        self.val = val\n        self.left = <span class=\"hljs-literal\">None</span>\n        self.right = <span class=\"hljs-literal\">None</span>\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">root</span>):\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n        <span class=\"hljs-keyword\">return</span>\n\n    queue = deque([root])\n\n    <span class=\"hljs-keyword\">while</span> queue:\n        node = queue.popleft()\n        <span class=\"hljs-built_in\">print</span>(node.val, end=<span class=\"hljs-string\">\" \"</span>)\n\n        <span class=\"hljs-keyword\">if</span> node.left:\n            queue.append(node.left)\n        <span class=\"hljs-keyword\">if</span> node.right:\n            queue.append(node.right)\n\n<span class=\"hljs-comment\"># Example usage</span>\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-comment\"># Construct the tree</span>\n    <span class=\"hljs-comment\">#       1</span>\n    <span class=\"hljs-comment\">#      / \\</span>\n    <span class=\"hljs-comment\">#     2   3</span>\n    <span class=\"hljs-comment\">#    / \\   \\</span>\n    <span class=\"hljs-comment\">#   4   5   6</span>\n    root = TreeNode(<span class=\"hljs-number\">1</span>)\n    root.left = TreeNode(<span class=\"hljs-number\">2</span>)\n    root.right = TreeNode(<span class=\"hljs-number\">3</span>)\n    root.left.left = TreeNode(<span class=\"hljs-number\">4</span>)\n    root.left.right = TreeNode(<span class=\"hljs-number\">5</span>)\n    root.right.right = TreeNode(<span class=\"hljs-number\">6</span>)\n\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"BFS traversal of the tree:\"</span>)\n    bfs(root)\n</code></pre>\n<h2>BFS for Level-Order Traversal</h2>\n<p>Sometimes we want <code>BFS</code> not just for traversal but to separate nodes by level. Here’s an example:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs_level_order</span>(<span class=\"hljs-params\">root</span>):\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> root:\n        <span class=\"hljs-keyword\">return</span> []\n\n    result = []\n    queue = deque([root])\n\n    <span class=\"hljs-keyword\">while</span> queue:\n        level_size = <span class=\"hljs-built_in\">len</span>(queue)\n        level = []\n        <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            <span class=\"hljs-keyword\">if</span> node.left:\n                queue.append(node.left)\n            <span class=\"hljs-keyword\">if</span> node.right:\n                queue.append(node.right)\n        result.append(level)\n\n    <span class=\"hljs-keyword\">return</span> result\n\n<span class=\"hljs-comment\"># Example usage</span>\nlevels = bfs_level_order(root)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Level-order traversal:\"</span>)\n<span class=\"hljs-built_in\">print</span>(levels)\n\n</code></pre>\n<h2>Summary</h2>\n<p><code>BFS</code> explores nodes level by level using a queue.</p>\n<p>It's ideal for shortest path problems, level-order traversal, and proximity-based searches.</p>\n<p>Python’s <code>collections.deque</code> makes implementing the <code>BFS</code> queue efficient.</p>\n<p><code>BFS</code> guarantees that nodes are visited in order of their distance from the root, unlike <code>DFS</code> which can go deep into one branch first.</p>\n"}},"__N_SSG":true}