{"pageProps":{"noteKey":["rust","macros"],"note":{"title":"Rust - Macros","date":"2022-03-16","content":"\n<p><code>Macros</code> is a Rust way of <code>metaprogramming</code> - writing a code that creates another code.</p>\n<p>\n  <code>println!</code> and <code>vec!</code> are examples of macroses. Internally they execute more code, that has to be\n  written manually. e.g. with <code>vec!</code> it is possible to create an instance of <code>Vec&#x3C;T></code> and add some\n  values inside of it during single statement.\n</p>\n<p>\n  Macros are similar to functions, but the bigges difference between them in moment of execution -\n  <code>function</code> is executed in runtime, whereas <code>macros</code> is executed during compile time. That quality\n  allows for example implement trait for some type inside of a <code>macros</code>.\n</p>\n<p>\n  The main con for <code>macros</code> is higher complexity to write and read. Also macros have to be defined\n  strictly before place, where it is used.\n</p>\n<p><strong>Macros types in Rust:</strong></p>\n<ul>\n  <li>declarative - declared with <code>macro_rules!</code></li>\n  <li>procedural:\n    <ul>\n      <li>\n        Custom <code>#[derive]</code> macros that specify code added with the derive attribute used on structs\n        and enums\n      </li>\n      <li><code>Attribute-like</code> macros that define custom attributes usable on any item</li>\n      <li>\n        <code>Function-like</code> macros that look like function calls but operate on the tokens specified as\n        their argument\n      </li>\n    </ul>\n  </li>\n</ul>\n<h2>Declarative macros</h2>\n<p>\n  <code>Declarative macros</code> are something similar to <code>match</code> expressions, which allows to get values,\n  compare it with some value and then execute required branch of code and do it on compilation stage.\n</p>\n<p><code>declarative macros</code> are defined with <code>macro_rules!</code>.</p>\n<p>Consider for example <code>vec!</code> macro, which allows to create filled <code>Vec&#x3C;T></code> instance:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[macro_export]</span>\n<span class=\"hljs-built_in\">macro_rules!</span> vec {\n    ( $( $x:expr ),* ) => {\n        {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">temp_vec</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n            $(\n                temp_vec.<span class=\"hljs-title function_ invoke__\">push</span>($x);\n            )*\n            temp_vec\n        }\n    };\n}\n</code></pre>\n<p>\n  <code>#[macro_export]</code> allows to import created macro into usage scope. <code>macro_rules!</code> is a beginning of\n  macro definition. After we define the name of the macro and then starts the scope of the macro.\n  Macro definition has a structure similar to <code>match</code> expresstion, where it is possible to define\n  several arm cases with pattern on the left side and executable code on the right.\n</p>\n<p>\n  Here <code>( $( $x:expr ),* )</code> is a pattern. When user enters inside of a macro value data, which will\n  match this pattern, the code, assosiated with it will be executed.\n</p>\n<p><strong>Pattern syntax:</strong></p>\n<p>\n  Pattern begins with <code>(...)</code>. Inside <code>$(...)</code> captures entered value. <code>$x:expr</code> defines a name <code>$x</code>\n  for captured value. <code>expr</code> is a Rust expression. <code>,</code> indicates, that after captured expression\n  comma character may appear. And finally <code>*</code> indicates, that this patter may be repetetive.\n</p>\n<p>So for <code>vec![1, 2, 3];</code> this pattern will capture numbers 1, 2 and 3 repetitively.</p>\n<p>\n  Inside of arm executable code we defined <code>$(...)*</code>, which means that code inside of it will be\n  emmitted for every <code>$( $x:expr )</code> pattern match.\n</p>\n<p>That way, after this macro will generate actual Rust code, it will emit:</p>\n<pre><code class=\"hljs language-rust\">{\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">temp_vec</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    temp_vec.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">1</span>);\n    temp_vec.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">2</span>);\n    temp_vec.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-number\">3</span>);\n    temp_vec\n}\n</code></pre>\n<h2>References</h2>\n<ul>\n  <li><a href=\"https://doc.rust-lang.org/stable/book/ch19-06-macros.html\">Macros - The Rust Programming Language</a></li>\n</ul>\n"}},"__N_SSG":true}