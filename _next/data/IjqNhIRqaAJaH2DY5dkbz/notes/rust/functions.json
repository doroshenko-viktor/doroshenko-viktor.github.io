{"pageProps":{"noteKey":["rust","functions"],"note":{"title":"Rust - Functions","date":"2022-03-15","content":"\n<h2>Delegating Functions With Function Pointers</h2>\n<p>\n  Function pointers allow to pass regular function into other functions as a parameters.\n  The <code>fn</code> type is called a function pointer.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_one</span>(x: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span> {\n    x + <span class=\"hljs-number\">1</span>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">do_twice</span>(f: <span class=\"hljs-title function_ invoke__\">fn</span>(<span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span>, arg: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-title function_ invoke__\">f</span>(arg) + <span class=\"hljs-title function_ invoke__\">f</span>(arg)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">answer</span> = <span class=\"hljs-title function_ invoke__\">do_twice</span>(add_one, <span class=\"hljs-number\">5</span>);\n\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"The answer is: {}\"</span>, answer);\n}\n</code></pre>\n<p>\n  Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type\n  directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.\n</p>\n<p>\n  Function pointers implement all three of the closure traits <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>, so you\n  can always pass a function pointer as an argument for a function that expects a closure. Itâ€™s\n  best to write functions using a generic type and one of the closure traits so your functions can\n  accept either functions or closures.\n</p>\n<h2>Closures</h2>\n<p>\n  To return closure from a function it must be wrapped into some smart pointer, because it does not\n  clear in the compile time, how much space a closure will take.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">returns_closure</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Box</span>&#x3C;<span class=\"hljs-keyword\">dyn</span> <span class=\"hljs-title function_ invoke__\">Fn</span>(<span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span>> {\n    Box::<span class=\"hljs-title function_ invoke__\">new</span>(|x| x + <span class=\"hljs-number\">1</span>)\n}\n</code></pre>\n"}},"__N_SSG":true}