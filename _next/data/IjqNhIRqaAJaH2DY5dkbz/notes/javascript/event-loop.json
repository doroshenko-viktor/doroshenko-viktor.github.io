{"pageProps":{"noteKey":["javascript","event-loop"],"note":{"title":"JavaScript Event Loop","date":"2022-06-18","content":"\n<p>\n  <code>JavaScript</code> is a generally single threaded programming language. It is possible to achieve some level\n  of concurrency with working threads. But anyway, to run them whole new runtime will be risen.\n  This way any long processing will block execution of whole program. But some long running tasks do not\n  require CPU computation. In their count for example <code>IO</code> operations and timeouts or handling events.\n  While waiting for a database response, program could continue some of it's processes.\n</p>\n<p>\n  Event loop in <code>JS</code> allows to perform such operations asynchronously. In simple words program can start\n  such long running task, which does not require CPU computation give it to the environment and immediately\n  continue to work on further instructions not waiting for completion of this task. Environment takes care of\n  completing task and once it happened return the result to main program through event loop. Tasks taken by\n  environment are executed in separate threads, but outside of main program runtime. This way program single threaded runtime called <code>main thread</code>.\n</p>\n<p>\n  <code>JS environment</code> may differ from the context of execution. It may be a browser api for the frontend or\n  <code>libuv</code> in <code>node.js</code>.\n</p>\n<p>\n  Basically <code>event loop</code> is an infinite loop, which waits until main thread stack is empty, then trying to take\n  a task from the task queue.\n  It takes oldest task, places it into the main thread stack and the process loops. If there is no tasks in the queue,\n  <code>event loop</code> simply waits until they appear. Any user or system event ocurred and created new task in the queue.\n</p>\n<p>While waiting for tasks to appear, event loop is very efficient in terms of CPU usage.</p>\n<h2>How It Works In Details</h2>\n<p>Simplest example:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'1'</span>);\n\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'2'</span>);\n}, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'3'</span>);\n</code></pre>\n<p>\n  Here <code>console.log('1');</code> is a synchronous function call, which will be executed immediately and print <code>1</code>\n  into the console. Next instruction <code>setTimeout</code> is asynchronous function call. It will create a task\n  in the environment, which should wait for a given period of time(in this case 0 seconds) and run code inside\n  of a given callback function.\n</p>\n<p>\n  As <code>setTimeout</code> is an <code>async</code> function, it's only job is to create a task in the <code>JS</code> environment. Our program\n  will do only this on it's way and will go to the next instruction.\n</p>\n<p><em>And it does not matter that, timeout is 0, the way is always the same - create task and go further.</em></p>\n<p>Next instruction is <code>console.log('3');</code>, which is also synchronous and will print <code>3</code> to the console.</p>\n<p>Now we have following output in our console:</p>\n<pre><code class=\"hljs language-txt\">1\n3\n</code></pre>\n<p>\n  But program didn't finish it's execution. We still have task, created by <code>setTimeout</code>. It is running in\n  parallel to the main program inside of <code>JS</code> environment. And while timeout was 0 it is already completed.\n  But to print <code>2</code> to the console it should go through couple of steps in event loop.\n</p>\n<p>\n  Event loop is kind of a <code>FIFO queue</code>. When <code>async</code> task is finished, environment places result callback to\n  the end of the event loop. When current call stack is empty, our program checks, if something appeared in\n  the event loop. If it is not empty first or in another words oldest item will be taken and placed to the\n  call stack.\n</p>\n<p>\n  On this step, when two <code>console.log</code> instructions have already been executed and printed <code>1</code> and <code>3</code>,\n  call stack of our program is empty. So it checks if there is something in the event loop. And luckily\n  there is a task to call function:\n</p>\n<pre><code class=\"hljs language-js\">() => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'2'</span>);\n}\n</code></pre>\n<p>\n  Which was provided to <code>setTimeout</code> when main program executed it and then, after async task has been\n  completed placed to the event loop by the environment. Now main program moves it to the stack and executes\n  <code>console.log('2');</code> instruction, which will print <code>2</code> to the console.\n</p>\n<h2>Events</h2>\n<p>\n  When some events happening, they don't go directly to call stack. Same as with async tasks all events go\n  through event loop queue. For example, if <code>onclick</code> event risen after button click it is queued in event\n  loop. Which means that it will be handled only after current call stack will be cleared. This may be a\n  reason of delays of event handling if we are blocking main thread.\n</p>\n<h2>Browser Rendering</h2>\n<p>Browser renders displaying picture also as a part of an event loop.</p>\n<p>\n  Same as for events applies to rendering. There are several steps browser makes to render a picture on a\n  display. But these steps are also a part of the event loop. So if we run blocking code in the stack, rendering\n  also could stuck.\n</p>\n<p>Rendering steps are:</p>\n<ul>\n  <li><code>style</code> - calculate colors, sizes, fonts and other <code>css</code> and assign them to elements</li>\n  <li><code>layout</code> - apply position to all elements</li>\n  <li><code>paint</code> - using graphics library, create precise image</li>\n</ul>\n<p>\n  Result of these steps is <code>Frame</code> - array of pixels, which will be directly displayed on the user screen.\n  If the <code>DOM</code> has been changed, browser has to execute all 3 steps and regenerate <code>Frame</code>.\n</p>\n<p>\n  But while rendering steps are part of event loop, they have higher priority than other tasks. Event if event\n  queue already contains some scheduled events, rendering steps will be performed before them.\n</p>\n<p>Ideally when there is no blocking tasks, render steps are executed 60 times per second.</p>\n<h3>Rendering With <code>requestAnimationFrame</code></h3>\n<p>\n  If you need to make a changes related to rendering to the display it there is a special method for this -\n  <code>requestAnimationFrame</code>. It is called immediately before rendering steps. The reason, why it is better to\n  use this method, instead of queuing a task - it is predictable. It runs regularly with target to create\n  60 frames per second. Task can be executed in event loop in any time causing uncontrollable behavior of a\n  picture. Tasks may cause rerendering with a random frame rate.\n</p>\n<p>\n  For example, using <code>setTimeout</code> for animation we may schedule several update per single frame, which is a\n  waste of a computational power. Moreover, as this is not designed for animation event if we trying to\n  schedule tasks to recalculate picture once per frame, there still could be some misses, e.g. garbage\n  collection started and such task will not hit necessary frame, but on the next frame we will have two\n  calculations.\n</p>\n<h2>Microtasks</h2>\n<p>\n  The main difference of <code>microtask</code> from regular task is in queue consumption. While main task queue executes\n  task one by one and allows page rendering stages between them, microtask queue when started execution, blocks\n  the main thread until all microtask queue will not be empty. This is useful, when we need to schedule next\n  task and ensure it will be handled before next rerender phase.\n</p>\n<p><code>Promises</code> internally implemented using microtasks.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">\"1\"</span>));\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">\"2\"</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"3\"</span>);\n</code></pre>\n<p>this example will print</p>\n<pre><code class=\"hljs language-txt\">3\n2\n1\n</code></pre>\n<p>\n  to the console. This is happening because <code>setTimeout</code> schedules regular task and <code>Promise</code> creates a microtask,\n  which has priority over macrotasks.\n</p>\n<p>\n  If we need to ensure, that application state will not be changed after we schedule a task, we can use <code>queueMicrotask</code>\n  function. It will create a new task in microtask queue, which will have a priority over all other tasks, such as\n  event listeners and macrotasks.\n</p>\n<h2>Performance Tips</h2>\n<p>\n  When there is a need to perform some heavy calculation, which may potentially block the main thread it may\n  be a good idea to split it in time. For example using <code>setTimeout</code> with <code>0</code> delay. This will reschedule some\n  part of heavy code into the event loop task queue, which will introduce possibility for rerendering the\n  content of the page.\n</p>\n<p>Such separation does not make a big difference in overall heavy calculation time, but increases page responsiveness.</p>\n<p>\n  Another option is separating heavy calculation to the working thread. Such a way we can introduce some kind\n  of multithreading. Our main thread will execute only light tasks and rendering, while blocking calculation\n  in working thread will not affect page responsiveness.\n</p>\n<h2>References</h2>\n<ul>\n  <li><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li>\n  <li><a href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a></li>\n  <li><a href=\"https://javascript.info/event-loop\">https://javascript.info/event-loop</a></li>\n</ul>\n"}},"__N_SSG":true}