{"pageProps":{"noteKey":["algorithms","graphs"],"note":{"title":"Graphs","date":"2022-03-31","content":"\n<p>\n  <code>Graph</code> is a data structure, which models set of connections or edges. These connections generally may be not\n  ordered like for array for example. Each node(also may be called vertices) in graph can have many connection to other nodes.\n</p>\n<p>Minimal requirement for graph - to have at least one node.</p>\n<p>\n  <img src=\"/_images/graphs-1.png\" alt=\"graph example\">\n</p>\n<p>\n  While many data structures, like trees, tries, linked lists and many others are special cases of graphs\n  and they have some root nodes, in general case graphs may not have any special root element, because\n  there may be many non directional multiple connections between nodes.\n</p>\n<h2>Graph Direction</h2>\n<p>Graphs may be undirected, directed or combined.</p>\n<p>\n  When graph is undirected means, that connection between two nodes can lead towards the second node and\n  also backwards. Moreover to be called undirected graph all it's connections have to be undirected.\n  Following example shows equivalent graphs:\n</p>\n<p>\n  <img src=\"/_images/graphs-2.png\" alt=\"non-directional graph\">\n</p>\n<p>\n  In directed graphs connection always links from one node to another, but opposite does not exist. And\n  by analogy from undirected graphs, to be called <code>directed</code>, graph must have all edges to be directed.\n</p>\n<h2>Breadth First Search</h2>\n<p>This is an algorithm, which allows to get an answer on two question regarding given graph;</p>\n<ul>\n  <li>Is there a way from node <code>A</code> to node <code>B</code></li>\n  <li>Which is a shortest way from <code>A</code> to <code>B</code></li>\n</ul>\n<p>\n  Consider following task. We have a graph with nodes of different colors. We need to find shortest way\n  from red node to any orange node.\n</p>\n<p>\n  <img src=\"/_images/graphs-3.png\" alt=\"graph-bfs-example\">\n</p>\n<p>\n  To achieve that, we run simple algorithm. As a first step, we try to find orange node between nodes,\n  which are linked with our initial red node. This is done by simple iteration through list of them.\n  Red node with value <code>1</code> linked with nodes indexed <code>2</code>, <code>3</code> and <code>4</code>. Non of them is orange. Next we try\n  to find orange nodes between relatives of <code>2</code>, <code>3</code> and <code>4</code>. Those nodes will be <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>,\n  <code>10</code>, <code>11</code>. Node <code>11</code> is orange, which means our search is finished.\n</p>\n<p>\n  As a result we not only found required orange node, but also this node has a shortest path to origin\n  node, where we started our search. Note, that we have other orange nodes <code>12</code> and <code>13</code>, but they have\n  longer path, so these nodes are not the answer.\n</p>\n<p>\n  Other thing that should be highlighted - we have some nodes, which linked by more than one neighbor\n  nodes, e.g. node <code>4</code> is linked by nodes <code>1</code> and <code>2</code>. This could be a problem. When we checked relatives\n  of node <code>1</code> we check node <code>4</code>. Then, when there was no answer we go to relatives of node <code>2</code> which\n  also points to node <code>4</code>. But we should not check it for the second time. This means, that we have to\n  track, what nodes have already been checked. Not doing this not only inefficient, but also can lead to\n  cycles. In this case search will not be finished at all.\n</p>\n<p>For example:</p>\n<p>\n  <img src=\"/_images/graphs-4.png\" alt=\"bfs-cycle\">\n</p>\n<p><code>1</code> points to <code>2</code>. <code>2</code> points to <code>3</code> and finally <code>3</code> points to <code>1</code>. Here we are in infinite loop.</p>\n<h2>Plan</h2>\n<p>\n  Breadth First Search\n  Dijkstra Algorithm\n</p>\n<h2>References</h2>\n<h2>Next</h2>\n<p>\n  <a href=\"https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e\">https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e</a>\n  <a href=\"https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688\">https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688</a>\n  <a href=\"https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13\">https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13</a>\n  <a href=\"https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255\">https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255</a>\n  <a href=\"https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38\">https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38</a>\n</p>\n"}},"__N_SSG":true}