{"pageProps":{"noteKey":["javascript","event-loop"],"note":{"title":"JavaScript Event Loop","date":"2022-06-18","content":"\n<p>\n  <code>JavaScript</code> is a generally single threaded programming language. It is possible to achieve some level\n  of concurrency with working threads. But anyway, to run them whole new runtime will be risen.\n  This way any long processing will block execution of whole program. But some long running tasks do not\n  require CPU computation. In their count for example <code>IO</code> operations and timeouts or handling events.\n  While waiting for a database response, program could continue some of it's processes.\n</p>\n<p>\n  Event loop in <code>JS</code> allows to perform such operations asynchronously. In simple words program can start\n  such long running task, which does not require CPU computation give it to the environment and immediately\n  continue to work on further instructions not waiting for completion of this task. Environment takes care of\n  completing task and once it happened return the result to main program through event loop. Tasks taken by\n  environment are executed in separate threads, but outside of main program runtime. This way program single threaded runtime called <code>main thread</code>.\n</p>\n<p>\n  <code>JS environment</code> may differ from the context of execution. It may be a browser api for the frontend or\n  <code>libuv</code> in <code>node.js</code>.\n</p>\n<h2>How It Works In Details</h2>\n<p>Simplest example:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'1'</span>);\n\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'2'</span>);\n}, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'3'</span>);\n</code></pre>\n<p>\n  Here <code>console.log('1');</code> is a synchronous function call, which will be executed immediately and print <code>1</code>\n  into the console. Next instruction <code>setTimeout</code> is asynchronous function call. It will create a task\n  in the environment, which should wait for a given period of time(in this case 0 seconds) and run code inside\n  of a given callback function.\n</p>\n<p>\n  As <code>setTimeout</code> is an <code>async</code> function, it's only job is to create a task in the <code>JS</code> environment. Our program\n  will do only this on it's way and will go to the next instruction.\n</p>\n<p><em>And it does not matter that, timeout is 0, the way is always the same - create task and go further.</em></p>\n<p>Next instruction is <code>console.log('3');</code>, which is also synchronous and will print <code>3</code> to the console.</p>\n<p>Now we have following output in our console:</p>\n<pre><code class=\"hljs language-txt\">1\n3\n</code></pre>\n<p>\n  But program didn't finish it's execution. We still have task, created by <code>setTimeout</code>. It is running in\n  parallel to the main program inside of <code>JS</code> environment. And while timeout was 0 it is already completed.\n  But to print <code>2</code> to the console it should go through couple of steps in event loop.\n</p>\n<p>\n  Event loop is kind of a <code>FIFO queue</code>. When <code>async</code> task is finished, environment places result callback to\n  the end of the event loop. When current call stack is empty, our program checks, if something appeared in\n  the event loop. If it is not empty first or in another words oldest item will be taken and placed to the\n  call stack.\n</p>\n<p>\n  On this step, when two <code>console.log</code> instructions have already been executed and printed <code>1</code> and <code>3</code>,\n  call stack of our program is empty. So it checks if there is something in the event loop. And luckily\n  there is a task to call function:\n</p>\n<pre><code class=\"hljs language-js\">() => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'2'</span>);\n}\n</code></pre>\n<p>\n  Which was provided to <code>setTimeout</code> when main program executed it and then, after async task has been\n  completed placed to the event loop by the environment. Now main program moves it to the stack and executes\n  <code>console.log('2');</code> instruction, which will print <code>2</code> to the console.\n</p>\n<h2>Events</h2>\n<p>\n  When some events happening, they don't go directly to call stack. Same as with async tasks all events go\n  through event loop queue. For example, if <code>onclick</code> event risen after button click it is queued in event\n  loop. Which means that it will be handled only after current call stack will be cleared. This may be a\n  reason of delays of event handling if we are blocking main thread.\n</p>\n<h2>Browser Rendering</h2>\n<p>Browser renders displaying picture also as a part of an event loop.</p>\n<p>\n  Same as for events applies to rendering. There are several steps browser makes to render a picture on a\n  display. But these steps are also a part of the event loop. So if we run blocking code in the stack, rendering\n  also could stuck.\n</p>\n<p>Rendering steps are:</p>\n<ul>\n  <li><code>style</code> - calculate colors, sizes, fonts and other <code>css</code> and assign them to elements</li>\n  <li><code>layout</code> - apply position to all elements</li>\n  <li><code>paint</code> - using graphics library, create precise image</li>\n</ul>\n<p>\n  Result of these steps is <code>Frame</code> - array of pixels, which will be directly displayed on the user screen.\n  If the <code>DOM</code> has been changed, browser has to execute all 3 steps and regenerate <code>Frame</code>.\n</p>\n<p>\n  But while rendering steps are part of event loop, they have higher priority than other tasks. Event if event\n  queue already contains some scheduled events, rendering steps will be performed before them.\n</p>\n<p>Ideally when there is no blocking tasks, render steps are executed 60 times per second.</p>\n<h3>requestAnimationFrame</h3>\n<p>\n  If you need to make a changes related to rendering to the display it there is a special method for this -\n  <code>requestAnimationFrame</code>. It is called immediately before rendering steps. The reason, why it is better to\n  use this method, instead of queuing a task - it is predictable. It runs regularly with target to create\n  60 frames per second. Task can be executed in event loop in any time causing uncontrollable behavior of a\n  picture. Tasks may cause rerendering with a random frame rate.\n</p>\n<p>\n  For example, using <code>setTimeout</code> for animation we may schedule several update per single frame, which is a\n  waste of a computational power. Moreover, as this is not designed for animation event if we trying to\n  schedule tasks to recalculate picture once per frame, there still could be some misses, e.g. garbage\n  collection started and such task will not hit necessary frame, but on the next frame we will have two\n  calculations.\n</p>\n<h2>References</h2>\n<ul>\n  <li><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li>\n  <li><a href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a></li>\n  <li><a href=\"https://javascript.info/event-loop\">https://javascript.info/event-loop</a></li>\n</ul>\n"}},"__N_SSG":true}