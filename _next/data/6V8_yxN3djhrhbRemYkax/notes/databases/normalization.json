{"pageProps":{"noteKey":["databases","normalization"],"note":{"title":"Relational Database Normalization","date":"2025-10-17","content":"\n<p>Database normalization is a systematic approach to organizing data in a relational database to reduce redundancy and improve data integrity. By applying normalization principles, database designers create efficient, maintainable structures that minimize anomalies during data operations. This comprehensive guide explores the concept of normal forms, their practical applications, and real-world examples.</p>\n<h2>What is Database Normalization?</h2>\n<p>Normalization is the process of structuring a relational database according to a series of progressive normal forms. Each normal form represents a level of database organization, with higher normal forms indicating more refined structures. The primary goals of normalization include:</p>\n<ul>\n  <li><strong>Eliminating redundant data</strong> to save storage space and reduce inconsistencies</li>\n  <li><strong>Ensuring data dependencies make sense</strong> by organizing related data appropriately</li>\n  <li><strong>Preventing update, insertion, and deletion anomalies</strong> that can corrupt data integrity</li>\n  <li><strong>Making database maintenance easier</strong> through logical, consistent structures</li>\n</ul>\n<h2>Understanding Functional Dependencies</h2>\n<p>Before diving into normal forms, it's essential to understand functional dependencies, which form the foundation of normalization theory.</p>\n<p>A functional dependency exists when one attribute (or set of attributes) uniquely determines another attribute. We write this as A → B, meaning \"A determines B\" or \"B is functionally dependent on A.\"</p>\n<p>For example, in a student database:</p>\n<ul>\n  <li>StudentID → StudentName (student ID uniquely determines student name)</li>\n  <li>CourseID → CourseName (course ID uniquely determines course name)</li>\n  <li>(StudentID, CourseID) → Grade (the combination determines the grade)</li>\n</ul>\n<h2>First Normal Form (1NF)</h2>\n<p>First Normal Form establishes the basic requirements for a table to be considered relational. A table is in 1NF if:</p>\n<ol>\n  <li>All columns contain atomic (indivisible) values</li>\n  <li>Each column contains values of a single type</li>\n  <li>Each column has a unique name</li>\n  <li>The order of rows and columns doesn't matter</li>\n  <li>Each row is unique (has a primary key)</li>\n</ol>\n<h3>Example: Achieving 1NF</h3>\n<p><strong>Non-1NF Table:</strong></p>\n<pre><code class=\"hljs language-arduino\">Orders\nOrderID | CustomerName | Products\n<span class=\"hljs-number\">1</span>       | John Smith   | Laptop, <span class=\"hljs-built_in\">Mouse</span>, <span class=\"hljs-built_in\">Keyboard</span>\n<span class=\"hljs-number\">2</span>       | Jane Doe     | Monitor, HDMI Cable\n</code></pre>\n<p>The <code>Products</code> column contains multiple values, violating atomicity.</p>\n<p><strong>Converted to 1NF:</strong></p>\n<pre><code class=\"hljs language-arduino\">Orders\nOrderID | CustomerName | Product\n<span class=\"hljs-number\">1</span>       | John Smith   | Laptop\n<span class=\"hljs-number\">1</span>       | John Smith   | <span class=\"hljs-built_in\">Mouse</span>\n<span class=\"hljs-number\">1</span>       | John Smith   | <span class=\"hljs-built_in\">Keyboard</span>\n<span class=\"hljs-number\">2</span>       | Jane Doe     | Monitor\n<span class=\"hljs-number\">2</span>       | Jane Doe     | HDMI Cable\n</code></pre>\n<p>Now each cell contains a single atomic value, though this structure introduces redundancy that higher normal forms will address.</p>\n<h2>Second Normal Form (2NF)</h2>\n<p>A table is in Second Normal Form if:</p>\n<ol>\n  <li>It is in 1NF</li>\n  <li>All non-key attributes are fully functionally dependent on the entire primary key (no partial dependencies)</li>\n</ol>\n<p>Partial dependencies occur when a non-key attribute depends on only part of a composite primary key. 2NF primarily applies to tables with composite primary keys.</p>\n<h3>Example: Achieving 2NF</h3>\n<p><strong>1NF Table with Partial Dependencies:</strong></p>\n<pre><code class=\"hljs language-css\">StudentCourses\nStudentID | CourseID | StudentName | CourseName | Grade\n<span class=\"hljs-number\">101</span>       | CS101    | Alice Brown | Databases  | <span class=\"hljs-selector-tag\">A</span>\n<span class=\"hljs-number\">101</span>       | CS102    | Alice Brown | Algorithms | <span class=\"hljs-selector-tag\">B</span>\n<span class=\"hljs-number\">102</span>       | CS101    | Bob Smith   | Databases  | <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>Primary Key: (StudentID, CourseID)</p>\n<p>Problems:</p>\n<ul>\n  <li>StudentName depends only on StudentID (partial dependency)</li>\n  <li>CourseName depends only on CourseID (partial dependency)</li>\n</ul>\n<p><strong>Converted to 2NF:</strong></p>\n<pre><code class=\"hljs language-css\">Students\nStudentID | StudentName\n<span class=\"hljs-number\">101</span>       | Alice Brown\n<span class=\"hljs-number\">102</span>       | Bob Smith\n\nCourses\nCourseID | CourseName\nCS101    | Databases\nCS102    | Algorithms\n\nEnrollments\nStudentID | CourseID | Grade\n<span class=\"hljs-number\">101</span>       | CS101    | <span class=\"hljs-selector-tag\">A</span>\n<span class=\"hljs-number\">101</span>       | CS102    | <span class=\"hljs-selector-tag\">B</span>\n<span class=\"hljs-number\">102</span>       | CS101    | <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>Now all non-key attributes in each table are fully dependent on their respective primary keys.</p>\n<h2>Third Normal Form (3NF)</h2>\n<p>A table is in Third Normal Form if:</p>\n<ol>\n  <li>It is in 2NF</li>\n  <li>No transitive dependencies exist (non-key attributes don't depend on other non-key attributes)</li>\n</ol>\n<p>A transitive dependency occurs when A → B and B → C, which means A → C indirectly.</p>\n<h3>Example: Achieving 3NF</h3>\n<p><strong>2NF Table with Transitive Dependencies:</strong></p>\n<pre><code class=\"hljs language-css\">Employees\nEmployeeID | EmployeeName | DepartmentID | DepartmentName | DepartmentLocation\n<span class=\"hljs-number\">1</span>          | John Doe     | D01          | Sales          | Building <span class=\"hljs-selector-tag\">A</span>\n<span class=\"hljs-number\">2</span>          | Jane Smith   | D01          | Sales          | Building <span class=\"hljs-selector-tag\">A</span>\n<span class=\"hljs-number\">3</span>          | Bob Johnson  | D02          | IT             | Building <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>Primary Key: EmployeeID</p>\n<p>Problem: DepartmentName and DepartmentLocation depend on DepartmentID, not directly on EmployeeID (transitive dependency: EmployeeID → DepartmentID → DepartmentName/DepartmentLocation).</p>\n<p><strong>Converted to 3NF:</strong></p>\n<pre><code class=\"hljs language-css\">Employees\nEmployeeID | EmployeeName | DepartmentID\n<span class=\"hljs-number\">1</span>          | John Doe     | D01\n<span class=\"hljs-number\">2</span>          | Jane Smith   | D01\n<span class=\"hljs-number\">3</span>          | Bob Johnson  | D02\n\nDepartments\nDepartmentID | DepartmentName | DepartmentLocation\nD01          | Sales          | Building <span class=\"hljs-selector-tag\">A</span>\nD02          | IT             | Building <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>This eliminates redundancy and ensures each table focuses on a single entity.</p>\n<h2>Boyce-Codd Normal Form (BCNF)</h2>\n<p>Boyce-Codd Normal Form is a stricter version of 3NF. A table is in BCNF if:</p>\n<ol>\n  <li>It is in 3NF</li>\n  <li>For every functional dependency A → B, A must be a superkey (a set of attributes that uniquely identifies rows)</li>\n</ol>\n<p>BCNF addresses situations where a table is in 3NF but still has anomalies due to overlapping candidate keys.</p>\n<h3>Example: Achieving BCNF</h3>\n<p><strong>3NF Table Not in BCNF:</strong></p>\n<pre><code class=\"hljs\">CourseInstructor\nStudentID | Course      | Instructor\n101       | Databases   | Dr. Smith\n101       | Algorithms  | Dr. Jones\n102       | Databases   | Dr. Smith\n</code></pre>\n<p>Assumptions:</p>\n<ul>\n  <li>Each student takes each course only once</li>\n  <li>Each course has only one instructor</li>\n  <li>An instructor teaches only one course, but a course might have multiple sections</li>\n</ul>\n<p>Primary Key: (StudentID, Course)</p>\n<p>Functional Dependencies:</p>\n<ul>\n  <li>(StudentID, Course) → Instructor</li>\n  <li>Instructor → Course (problematic: Instructor is not a superkey)</li>\n</ul>\n<p>The second dependency violates BCNF because Instructor is not a superkey.</p>\n<p><strong>Converted to BCNF:</strong></p>\n<pre><code class=\"hljs\">StudentEnrollment\nStudentID | Instructor\n101       | Dr. Smith\n101       | Dr. Jones\n102       | Dr. Smith\n\nInstructorCourse\nInstructor | Course\nDr. Smith  | Databases\nDr. Jones  | Algorithms\n</code></pre>\n<p>Now all functional dependencies have superkeys on the left side.</p>\n<h2>Fourth Normal Form (4NF)</h2>\n<p>A table is in Fourth Normal Form if:</p>\n<ol>\n  <li>It is in BCNF</li>\n  <li>It has no multi-valued dependencies (MVDs)</li>\n</ol>\n<p>A multi-valued dependency exists when one attribute determines multiple independent sets of values. Written as A →→ B, meaning for each value of A, there's a set of values for B independent of other attributes.</p>\n<h3>Example: Achieving 4NF</h3>\n<p><strong>BCNF Table with Multi-Valued Dependencies:</strong></p>\n<pre><code class=\"hljs language-sql\">EmployeeSkillsLanguages\nEmployeeID <span class=\"hljs-operator\">|</span> Skill        <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">Language</span>\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Java         <span class=\"hljs-operator\">|</span> English\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Java         <span class=\"hljs-operator\">|</span> Spanish\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Python       <span class=\"hljs-operator\">|</span> English\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Python       <span class=\"hljs-operator\">|</span> Spanish\n<span class=\"hljs-number\">2</span>          <span class=\"hljs-operator\">|</span> JavaScript   <span class=\"hljs-operator\">|</span> French\n</code></pre>\n<p>Employee 1 has skills {Java, Python} and speaks {English, Spanish}. These are independent - every combination appears.</p>\n<p>Multi-valued dependencies:</p>\n<ul>\n  <li>EmployeeID →→ Skill</li>\n  <li>EmployeeID →→ Language</li>\n</ul>\n<p><strong>Converted to 4NF:</strong></p>\n<pre><code class=\"hljs language-sql\">EmployeeSkills\nEmployeeID <span class=\"hljs-operator\">|</span> Skill\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Java\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Python\n<span class=\"hljs-number\">2</span>          <span class=\"hljs-operator\">|</span> JavaScript\n\nEmployeeLanguages\nEmployeeID <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">Language</span>\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> English\n<span class=\"hljs-number\">1</span>          <span class=\"hljs-operator\">|</span> Spanish\n<span class=\"hljs-number\">2</span>          <span class=\"hljs-operator\">|</span> French\n</code></pre>\n<p>This eliminates redundant combinations and keeps independent facts separate.</p>\n<h2>Fifth Normal Form (5NF)</h2>\n<p>A table is in Fifth Normal Form (also called Project-Join Normal Form) if:</p>\n<ol>\n  <li>It is in 4NF</li>\n  <li>It cannot be decomposed into smaller tables without loss of information</li>\n  <li>All join dependencies are implied by candidate keys</li>\n</ol>\n<p>5NF deals with cases where information can be reconstructed from smaller tables through joins.</p>\n<h3>Example: Achieving 5NF</h3>\n<p><strong>4NF Table with Join Dependencies:</strong></p>\n<pre><code class=\"hljs language-css\">AgentCompanyProduct\nAgent      | Company    | Product\nSmith      | Acme Corp  | Widget <span class=\"hljs-selector-tag\">A</span>\nSmith      | Acme Corp  | Widget <span class=\"hljs-selector-tag\">B</span>\nJones      | Acme Corp  | Widget <span class=\"hljs-selector-tag\">A</span>\nBrown      | Tech Inc   | Widget <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>Rules:</p>\n<ul>\n  <li>If an agent represents a company, and that company sells a product, and the agent sells that product, then the agent sells that product for that company</li>\n</ul>\n<p><strong>Converted to 5NF:</strong></p>\n<pre><code class=\"hljs language-css\">AgentCompany\nAgent      | Company\nSmith      | Acme Corp\nJones      | Acme Corp\nBrown      | Tech Inc\n\nCompanyProduct\nCompany    | Product\nAcme Corp  | Widget <span class=\"hljs-selector-tag\">A</span>\nAcme Corp  | Widget <span class=\"hljs-selector-tag\">B</span>\nTech Inc   | Widget <span class=\"hljs-selector-tag\">B</span>\n\nAgentProduct\nAgent      | Product\nSmith      | Widget <span class=\"hljs-selector-tag\">A</span>\nSmith      | Widget <span class=\"hljs-selector-tag\">B</span>\nJones      | Widget <span class=\"hljs-selector-tag\">A</span>\nBrown      | Widget <span class=\"hljs-selector-tag\">B</span>\n</code></pre>\n<p>The original information can be reconstructed by joining these three tables, eliminating redundancy while preserving all relationships.</p>\n<h2>Practical Considerations</h2>\n<h3>When to Normalize</h3>\n<p>Normalization is generally beneficial for:</p>\n<ul>\n  <li><strong>Transaction-heavy systems (OLTP)</strong> where data integrity and update performance matter</li>\n  <li><strong>Systems with frequent data modifications</strong> to prevent anomalies</li>\n  <li><strong>Multi-user environments</strong> where consistency is critical</li>\n  <li><strong>Applications requiring strict data integrity</strong></li>\n</ul>\n<h3>When to Denormalize</h3>\n<p>Sometimes controlled denormalization is appropriate:</p>\n<ul>\n  <li><strong>Read-heavy analytical systems (OLAP)</strong> where query performance is paramount</li>\n  <li><strong>Reporting databases</strong> that aggregate data from normalized sources</li>\n  <li><strong>Systems with specific performance bottlenecks</strong> after profiling</li>\n  <li><strong>When join operations significantly impact performance</strong></li>\n</ul>\n<p>Denormalization should be:</p>\n<ul>\n  <li>Strategic and documented</li>\n  <li>Applied after establishing a normalized foundation</li>\n  <li>Accompanied by mechanisms to maintain consistency</li>\n  <li>Based on actual performance measurements, not assumptions</li>\n</ul>\n<h2>Common Normalization Mistakes</h2>\n<p><strong>Over-normalization</strong>: Creating too many small tables can hurt query performance and complicate database design. Normalize to 3NF or BCNF for most applications.</p>\n<p><strong>Under-normalization</strong>: Leaving redundant data causes update anomalies and wastes storage. Always achieve at least 3NF for transactional systems.</p>\n<p><strong>Premature denormalization</strong>: Optimizing before identifying actual bottlenecks leads to unnecessary complexity.</p>\n<p><strong>Ignoring business rules</strong>: Normalization must respect the actual relationships and constraints in your domain.</p>\n<h2>SQL Examples</h2>\n<h3>Creating Normalized Tables</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 3NF Example: E-commerce Database</span>\n\n<span class=\"hljs-comment\">-- Customers table</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Customers (\n    CustomerID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    FirstName <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    LastName <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    Email <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    PhoneNumber <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>)\n);\n\n<span class=\"hljs-comment\">-- Products table</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Products (\n    ProductID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    ProductName <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    CategoryID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    Price <span class=\"hljs-type\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    StockQuantity <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (CategoryID) <span class=\"hljs-keyword\">REFERENCES</span> Categories(CategoryID)\n);\n\n<span class=\"hljs-comment\">-- Categories table</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Categories (\n    CategoryID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    CategoryName <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    Description TEXT\n);\n\n<span class=\"hljs-comment\">-- Orders table</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Orders (\n    OrderID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    CustomerID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    OrderDate DATETIME <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-built_in\">CURRENT_TIMESTAMP</span>,\n    ShippingAddressID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    TotalAmount <span class=\"hljs-type\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>),\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (CustomerID) <span class=\"hljs-keyword\">REFERENCES</span> Customers(CustomerID),\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (ShippingAddressID) <span class=\"hljs-keyword\">REFERENCES</span> Addresses(AddressID)\n);\n\n<span class=\"hljs-comment\">-- OrderItems table (intersection table)</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> OrderItems (\n    OrderItemID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    OrderID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    ProductID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    Quantity <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    UnitPrice <span class=\"hljs-type\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (OrderID) <span class=\"hljs-keyword\">REFERENCES</span> Orders(OrderID),\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (ProductID) <span class=\"hljs-keyword\">REFERENCES</span> Products(ProductID)\n);\n\n<span class=\"hljs-comment\">-- Addresses table (separate to avoid redundancy)</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Addresses (\n    AddressID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY AUTO_INCREMENT,\n    CustomerID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    Street <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    City <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    State <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>),\n    PostalCode <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>),\n    Country <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    <span class=\"hljs-keyword\">FOREIGN</span> KEY (CustomerID) <span class=\"hljs-keyword\">REFERENCES</span> Customers(CustomerID)\n);\n</code></pre>\n<h3>Querying Normalized Data</h3>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- Retrieve order details with customer and product information</span>\n<span class=\"hljs-keyword\">SELECT</span>\n    o.OrderID,\n    o.OrderDate,\n    c.FirstName,\n    c.LastName,\n    p.ProductName,\n    oi.Quantity,\n    oi.UnitPrice,\n    (oi.Quantity <span class=\"hljs-operator\">*</span> oi.UnitPrice) <span class=\"hljs-keyword\">AS</span> LineTotal\n<span class=\"hljs-keyword\">FROM</span> Orders o\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> Customers c <span class=\"hljs-keyword\">ON</span> o.CustomerID <span class=\"hljs-operator\">=</span> c.CustomerID\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> OrderItems oi <span class=\"hljs-keyword\">ON</span> o.OrderID <span class=\"hljs-operator\">=</span> oi.OrderID\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> Products p <span class=\"hljs-keyword\">ON</span> oi.ProductID <span class=\"hljs-operator\">=</span> p.ProductID\n<span class=\"hljs-keyword\">WHERE</span> o.OrderID <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1001</span>;\n\n<span class=\"hljs-comment\">-- Find all products in a specific category with stock levels</span>\n<span class=\"hljs-keyword\">SELECT</span>\n    p.ProductName,\n    p.Price,\n    p.StockQuantity,\n    cat.CategoryName\n<span class=\"hljs-keyword\">FROM</span> Products p\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> Categories cat <span class=\"hljs-keyword\">ON</span> p.CategoryID <span class=\"hljs-operator\">=</span> cat.CategoryID\n<span class=\"hljs-keyword\">WHERE</span> cat.CategoryName <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">'Electronics'</span>\n<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> p.ProductName;\n</code></pre>\n<h2>Summary Table: Normal Forms Quick Reference</h2>\n<table>\n  <thead>\n    <tr>\n      <th>Normal Form</th>\n      <th>Requirements</th>\n      <th>Eliminates</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><strong>1NF</strong></td>\n      <td>Atomic values, unique column names, primary key exists</td>\n      <td>Repeating groups, multi-valued attributes</td>\n    </tr>\n    <tr>\n      <td><strong>2NF</strong></td>\n      <td>1NF + No partial dependencies</td>\n      <td>Partial dependencies on composite keys</td>\n    </tr>\n    <tr>\n      <td><strong>3NF</strong></td>\n      <td>2NF + No transitive dependencies</td>\n      <td>Transitive dependencies</td>\n    </tr>\n    <tr>\n      <td><strong>BCNF</strong></td>\n      <td>3NF + Every determinant is a candidate key</td>\n      <td>Anomalies from overlapping candidate keys</td>\n    </tr>\n    <tr>\n      <td><strong>4NF</strong></td>\n      <td>BCNF + No multi-valued dependencies</td>\n      <td>Independent multi-valued facts</td>\n    </tr>\n    <tr>\n      <td><strong>5NF</strong></td>\n      <td>4NF + No join dependencies</td>\n      <td>Complex join dependencies</td>\n    </tr>\n  </tbody>\n</table>\n"}},"__N_SSG":true}