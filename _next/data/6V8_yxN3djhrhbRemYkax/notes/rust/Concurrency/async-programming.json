{"pageProps":{"noteKey":["rust","Concurrency","async-programming"],"note":{"title":"Rust Async Programming","date":"2022-06-02","content":"\n<p>\n  <code>Asynchronous programming</code> is a concurrency model, which allows to multiple independent tasks to\n  operate on base of smaller number of OS threads. It allows to greatly reduce workload in some\n  scenarios, like with heavy usage of <code>IO</code> operations. In this case if we use OS threads, means that\n  on each <code>IO</code> operation, thread will simply wait for it's completion, while in <code>async</code> model it can\n  resume it's work on another task. That allows smaller number of OS threads to do the same work,\n  saving a lot of performance on context switching.\n</p>\n<p>Particularly in Rust it is worth to always keep in mind, that:</p>\n<ul>\n  <li>\n    <code>Futures</code> (also known as <code>Tasks</code> in C# or <code>Promises</code> in JS languages) start doing their action\n    only whence actively triggered and they stop execution, when go out of scope and dropped.\n  </li>\n  <li>\n    Unlike other languages, Rust does not provide a runtime for <code>async</code> operations for performance\n    reasons. Custom <code>async</code> runtimes are provided by community. They can be single-threaded, like <code>V8</code>\n    in JS world or multithreaded.\n  </li>\n</ul>\n<p>\n  Rust natively provides <code>Future</code> trait and <code>async/await</code> keywords, some utility types in <code>futures</code>\n  crate. Other functionality can be used added by third party modules.\n</p>\n<h2>Async / Await</h2>\n<p><code>async/await</code> syntax allows to some blocks of code to return control on the thread instead of blocking.</p>\n<p><code>async</code> may be used on functions and blocks:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">some_function</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span> { \n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>or</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>\n  <code>async</code> block or function return <code>Future</code>, which will not run on fact of creation, it must be\n  triggered. To do so we can use <code>.await</code> method. After call of <code>.await</code> future is trying to complete\n  it's instructions, but if at some point it will be blocked, it will return control on thread it's\n  operating on. After blocking code will be ready, execution environment will return control on some\n  thread to the <code>Future</code> allowing to finish it's execution.\n</p>\n<p>If the <code>Future</code> accepts some parameters with non <code>'static</code> lifetime, it will be bound to their lifetime.</p>\n<p>To transform <code>Future</code> with custom lifetime reference to a <code>'static</code> lifetime there are some ways.</p>\n<p>Using <code>async</code> blocks:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bad</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Future</span>&#x3C;Output = <span class=\"hljs-type\">u8</span>> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-title function_ invoke__\">borrow_x</span>(&#x26;x) <span class=\"hljs-comment\">// ERROR: `x` does not live long enough</span>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">good</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Future</span>&#x3C;Output = <span class=\"hljs-type\">u8</span>> {\n    <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">x</span> = <span class=\"hljs-number\">5</span>;\n        <span class=\"hljs-title function_ invoke__\">borrow_x</span>(&#x26;x).<span class=\"hljs-keyword\">await</span>\n    }\n}\n</code></pre>\n<p>\n  Using <code>move</code> it is possible to give an ownership on some variables to the <code>Future</code> allowing them to\n  live more that outer context:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">blocks</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">my_string</span> = <span class=\"hljs-string\">\"foo\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>();\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">future_one</span> = <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{my_string}\"</span>);\n    };\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">future_two</span> = <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{my_string}\"</span>);\n    };\n\n    <span class=\"hljs-comment\">// Run both futures to completion, printing \"foo\" twice:</span>\n    <span class=\"hljs-keyword\">let</span> ((), ()) = futures::join!(future_one, future_two);\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">move_block</span>() <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Future</span>&#x3C;Output = ()> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">my_string</span> = <span class=\"hljs-string\">\"foo\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>();\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">move</span> {\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{my_string}\"</span>);\n    }\n}\n</code></pre>\n<h2>Stream</h2>\n<p>\n  <code>Stream</code> trait allows to emit multiple values before completion. It is like a combination of <code>Future</code>\n  and <code>Iterator</code>. For example <code>Receiver</code> for the channel type from the futures crate. It will yield <code>Some(val)</code> every time a value is sent from the <code>Sender</code> end, and will yield <code>None</code> once the <code>Sender</code> has been dropped and all pending messages have been received:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">send_recv</span>() {\n    <span class=\"hljs-keyword\">const</span> BUFFER_SIZE: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">let</span> (<span class=\"hljs-keyword\">mut</span> tx, <span class=\"hljs-keyword\">mut</span> rx) = mpsc::channel::&#x3C;<span class=\"hljs-type\">i32</span>>(BUFFER_SIZE);\n\n    tx.<span class=\"hljs-title function_ invoke__\">send</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-keyword\">await</span>.<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n    tx.<span class=\"hljs-title function_ invoke__\">send</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-keyword\">await</span>.<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n    <span class=\"hljs-title function_ invoke__\">drop</span>(tx);\n\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">1</span>), rx.<span class=\"hljs-title function_ invoke__\">next</span>().<span class=\"hljs-keyword\">await</span>);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">2</span>), rx.<span class=\"hljs-title function_ invoke__\">next</span>().<span class=\"hljs-keyword\">await</span>);\n    <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-literal\">None</span>, rx.<span class=\"hljs-title function_ invoke__\">next</span>().<span class=\"hljs-keyword\">await</span>);\n}\n</code></pre>\n<p>\n  It is possible to iterate on <code>Stream</code> like on <code>Iterator</code> with <code>map</code>, <code>filter</code>, <code>fold</code>, <code>try_map</code>, <code>try_filter</code> and <code>try_fold</code> as well as with <code>while let</code> loop. But it is not possible to use <code>for</code>\n  loop with a <code>Stream</code>.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">sum_with_next</span>(<span class=\"hljs-keyword\">mut</span> stream: Pin&#x3C;&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">dyn</span> Stream&#x3C;Item = <span class=\"hljs-type\">i32</span>>>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-keyword\">use</span> futures::stream::StreamExt; <span class=\"hljs-comment\">// for `next`</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">sum</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Some</span>(item) = stream.<span class=\"hljs-title function_ invoke__\">next</span>().<span class=\"hljs-keyword\">await</span> {\n        sum += item;\n    }\n    sum\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">sum_with_try_next</span>(\n    <span class=\"hljs-keyword\">mut</span> stream: Pin&#x3C;&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">dyn</span> Stream&#x3C;Item = <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">i32</span>, io::Error>>>,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">i32</span>, io::Error> {\n    <span class=\"hljs-keyword\">use</span> futures::stream::TryStreamExt; <span class=\"hljs-comment\">// for `try_next`</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">sum</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">Some</span>(item) = stream.<span class=\"hljs-title function_ invoke__\">try_next</span>().<span class=\"hljs-keyword\">await</span>? {\n        sum += item;\n    }\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(sum)\n}\n</code></pre>\n<p>To iterate concurrently:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">jump_around</span>(\n    <span class=\"hljs-keyword\">mut</span> stream: Pin&#x3C;&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">dyn</span> Stream&#x3C;Item = <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">u8</span>, io::Error>>>,\n) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;(), io::Error> {\n    <span class=\"hljs-keyword\">use</span> futures::stream::TryStreamExt; <span class=\"hljs-comment\">// for `try_for_each_concurrent`</span>\n    <span class=\"hljs-keyword\">const</span> MAX_CONCURRENT_JUMPERS: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-number\">100</span>;\n\n    stream.<span class=\"hljs-title function_ invoke__\">try_for_each_concurrent</span>(MAX_CONCURRENT_JUMPERS, |num| <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">move</span> {\n        <span class=\"hljs-title function_ invoke__\">jump_n_times</span>(num).<span class=\"hljs-keyword\">await</span>?;\n        <span class=\"hljs-title function_ invoke__\">report_n_jumps</span>(num).<span class=\"hljs-keyword\">await</span>?;\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(())\n    }).<span class=\"hljs-keyword\">await</span>?;\n\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(())\n}\n</code></pre>\n<h2>Joining <code>Futures</code></h2>\n<p>\n  Unlike other languages, where it is possible to run several async tasks and after that await for\n  them all, in Rust this is not possible, because <code>Future</code> does not start to execute upon creation.\n  But if we will try to create several <code>Futures</code> one after another and await them they will execute\n  sequentially and not concurrently.\n</p>\n<p>\n  When we run multiple <code>Futures</code> concurrently and need to wait until each of them will be completed,\n  we can use <code>futures::join</code> macro.\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> futures::join;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_book_and_music</span>() <span class=\"hljs-punctuation\">-></span> (Book, Music) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">book_fut</span> = <span class=\"hljs-title function_ invoke__\">get_book</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">music_fut</span> = <span class=\"hljs-title function_ invoke__\">get_music</span>();\n    join!(book_fut, music_fut)\n}\n</code></pre>\n<p>\n  This allows for two <code>Futures</code> to be executed in parallel. <code>join</code> returns tuple with results of\n  all <code>Futures</code> passed into it.\n</p>\n<p>\n  If concurrent <code>Futures</code> return <code>Result&#x3C;T></code> it may be useful to use <code>try_join</code>. It will stop execution,\n  if some of the futures returned an error result.\n</p>\n<p>All futures must have the same error type. To achieve this <code>.map_err(|e| ...)</code> and <code>.err_into()</code> functions from <code>futures::future::TryFutureExt</code> would be useful.</p>\n<h2>Select</h2>\n<p>\n  When running multiple <code>Futures</code> concurrently we need to wait only for the first completed of them,\n  we can use <a href=\"https://rust-lang.github.io/async-book/06_multiple_futures/03_select.html\"><code>futures::select</code></a> macro:\n</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> futures::{\n    future::FutureExt, <span class=\"hljs-comment\">// for `.fuse()`</span>\n    pin_mut,\n    select,\n};\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">task_one</span>() { <span class=\"hljs-comment\">/* ... */</span> }\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">task_two</span>() { <span class=\"hljs-comment\">/* ... */</span> }\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">race_tasks</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">t1</span> = <span class=\"hljs-title function_ invoke__\">task_one</span>().<span class=\"hljs-title function_ invoke__\">fuse</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">t2</span> = <span class=\"hljs-title function_ invoke__\">task_two</span>().<span class=\"hljs-title function_ invoke__\">fuse</span>();\n\n    pin_mut!(t1, t2);\n\n    <span class=\"hljs-built_in\">select!</span> {\n        () = t1 => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"task one completed first\"</span>),\n        () = t2 => <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"task two completed first\"</span>),\n    }\n}\n</code></pre>\n<p>When first <code>Future</code> completes, all other stop their execution.</p>\n<p>The basic syntax for <code>select</code> is <code>&#x3C;pattern> = &#x3C;expression> => &#x3C;code>,</code></p>\n"}},"__N_SSG":true}